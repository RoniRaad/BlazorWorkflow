@namespace BlazorExecutionFlow.Components
@using BlazorExecutionFlow.Flow.Attributes
@using BlazorExecutionFlow.Flow.BaseNodes 
@using System.Net.Http
@using System.Net.Http.Json
@using BlazorExecutionFlow.Services
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.AspNetCore.Components.Routing
@using Microsoft.AspNetCore.Components.Web
@using static Microsoft.AspNetCore.Components.Web.RenderMode
@using Microsoft.AspNetCore.Components.Web.Virtualization
@using Microsoft.JSInterop
@using BlazorExecutionFlow.Helpers
@using BlazorExecutionFlow.Models
@using BlazorExecutionFlow.Models.NodeV2
@using System.Text.Json
@using System.Collections.Frozen
@using static BlazorExecutionFlow.Helpers.DrawflowHelpers
@inherits BlazorExecutionFlowGraphBase
@inject IWorkflowService _workflowService

@if (showModal && editNode is not null)
{
    <NodeEditorModal SaveRequested=SaveChanges
    CloseRequested="@(() => showModal = false)"
    ExecuteInputRequested="ExecuteInputNodes"
    BackingNode="@(editNode)"></NodeEditorModal>
}

<div class="bef-lib drawflow-container">
    @if (IncludeControlPanel)
    {
        <div class="sidebar-panel">
            <div class="control-buttons">
                <button class="btn btn-sm btn-primary" @onclick="Run" aria-label="Run workflow">Run</button>
                <button class="btn btn-sm btn-primary" @onclick="Clear" aria-label="Clear workflow">Clear</button>
                <button class="btn btn-sm btn-success" @onclick="ExportCSharp" aria-label="Export to C# JSON">Export C#</button>
                <button class="btn btn-sm btn-primary" @onclick="() => showImportModal = true" aria-label="Import from C# JSON">Import C#</button>
            </div>
            <div class="node-browser">
                <div class="node-search">
                    <input @ref="searchInputRef"
                    type="text"
                    class="form-control"
                    placeholder="@(EffectiveSelectedCategory == null ? "Search sections..." : "Search nodes...")"
                    @bind="searchQuery"
                    @bind:event="oninput"
                    @onkeydown="HandleSearchKeyDown"
                    aria-label="Search"
                    autocomplete="off" />
                    <svg class="search-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="11" cy="11" r="8"></circle>
                        <path d="m21 21-4.35-4.35"></path>
                    </svg>
                    @if (!string.IsNullOrWhiteSpace(searchQuery))
                    {
                        <button class="search-clear" @onclick="ClearSearch" aria-label="Clear search">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <line x1="18" y1="6" x2="6" y2="18"></line>
                                <line x1="6" y1="6" x2="18" y2="18"></line>
                            </svg>
                        </button>
                    }
                </div>

                @if (EffectiveSelectedCategory != null)
                {
                    <div class="breadcrumb-nav">
                        <button class="breadcrumb-back" @onclick="BackToSections" aria-label="Back to sections">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M19 12H5M12 19l-7-7 7-7"/>
                            </svg>
                        </button>
                        <span class="breadcrumb-text">@EffectiveSelectedCategory</span>
                    </div>
                }

                <div class="node-list" style="@(EffectiveSelectedCategory is not null || selectedNodeIndex != -1 ? "max-height:calc(100vh - 440px)" : "")" @ref="nodeListRef">
                    @if (EffectiveSelectedCategory == null)
                    {
                        @* Show sections *@
                        var filteredSections = MatchingCategories.ToList();
                        if (filteredSections.Any())
                        {
                            for (int i = 0; i < filteredSections.Count; i++)
                            {
                                var section = filteredSections[i];
                                var index = i;
                                var isSelected = selectedNodeIndex == index;
                                var nodeCount = _nodes.Count(n => n.Section == section);
                                <button class="node-item section-item @(isSelected ? "selected" : "")"
                                @onclick="@(() => SelectSection(section))"
                                data-node-index="@index"
                                aria-label="Open @(section) section">
                                    <div class="node-content">
                                        <span class="node-name">@(section)</span>
                                        <span class="node-count">@nodeCount node@(nodeCount == 1 ? "" : "s")</span>
                                    </div>
                                    <svg class="chevron-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <path d="M9 18l6-6-6-6"/>
                                    </svg>
                                </button>
                            }
                        }
                        else
                        {
                            <div class="no-results">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <circle cx="12" cy="12" r="10"></circle>
                                    <path d="M12 8v4"></path>
                                    <path d="M12 16h.01"></path>
                                </svg>
                                <p>No sections found</p>
                            </div>
                        }
                    }
                    else
                    {
                        @* Show nodes within selected section *@
                        var filteredNodesList = FilteredNodes.ToList();
                        if (filteredNodesList.Any())
                        {
                            for (int i = 0; i < filteredNodesList.Count; i++)
                            {
                                var node = filteredNodesList[i];
                                var index = i;
                                var isSelected = selectedNodeIndex == index;
                                <button class="node-item @(isSelected ? "selected" : "")"
                                @onclick="@(() => CreateNode(node))"
                                data-node-index="@index"
                                aria-label="Create @node.Name node">
                                    <div class="node-content">
                                        <span class="node-name">@((MarkupString)HighlightMatch(TypeHelpers.AddSpacesToPascalCase(node.Name), searchQuery))</span>
                                    </div>
                                    @if (isSelected)
                                    {
                                        <svg class="node-selected-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                            <polyline points="9 11 12 14 22 4"></polyline>
                                            <path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"></path>
                                        </svg>
                                    }
                                </button>
                            }
                        }
                        else
                        {
                            <div class="no-results">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <circle cx="12" cy="12" r="10"></circle>
                                    <path d="M12 8v4"></path>
                                    <path d="M12 16h.01"></path>
                                </svg>
                                <p>No nodes found</p>
                                @if (!string.IsNullOrWhiteSpace(searchQuery))
                                {
                                    <button class="btn btn-sm btn-outline-secondary mt-2" @onclick="ClearSearch">Clear search</button>
                                }
                            </div>
                        }
                    }
                </div>
            </div>
        </div>
    }

    <div id="@ElementId" class="drawflow-host" style="@(Style ?? "height:500px;")"></div>
</div>

@if (!string.IsNullOrWhiteSpace(_exportJson))
{
    <div class="export-modal-backdrop" @onclick="() => _exportJson = null">
        <div class="export-modal" @onclick:stopPropagation="true">
            <div class="export-modal-header">
                <h3>C# Flow Export</h3>
                <button class="btn-close" @onclick="() => _exportJson = null">×</button>
            </div>
            <div class="export-modal-body">
                <button class="btn btn-sm btn-primary mb-2" @onclick="CopyToClipboard">Copy to Clipboard</button>
                <textarea class="export-textarea" readonly>@_exportJson</textarea>
            </div>
        </div>
    </div>
}

@if (showImportModal)
{
    <div class="export-modal-backdrop" @onclick="() => showImportModal = false">
        <div class="export-modal" @onclick:stopPropagation="true">
            <div class="export-modal-header">
                <h3>Import C# Flow</h3>
                <button class="btn-close" @onclick="() => showImportModal = false">×</button>
            </div>
            <div class="export-modal-body">
                <textarea class="export-textarea" @bind="_importJson" placeholder="Paste C# Flow JSON here..."></textarea>
                <div class="mt-2">
                    <button class="btn btn-sm btn-primary" @onclick="ImportCSharp">Import</button>
                    <button class="btn btn-sm btn-secondary" @onclick="() => showImportModal = false">Cancel</button>
                </div>
                @if (!string.IsNullOrWhiteSpace(_importError))
                {
                    <div class="alert alert-danger mt-2">@_importError</div>
                }
            </div>
        </div>
    </div>
}


@code {
    [Parameter] public EventCallback<string> OnNodeDoubleClicked { get; set; }
    [Parameter] public bool IncludeControlPanel { get; set; } = true;
    [Parameter] public bool EnableStatusAnimations { get; set; } = true;
    [Parameter] public Dictionary<string, string> WorkflowParameters { get; set; } = new();
    [Parameter] public Dictionary<string, string> EnvironmentVariables { get; set; } = new();

    private Dictionary<string, object> options = new Dictionary<string, object>() { ["reroute"] = true };
    private BlazorExecutionFlowGraphBase? _base;
    private string? _exportJson;
    private string? _importJson;
    private string? _importError;
    private List<Node> _nodes = [];
    private bool showModal = false;
    private bool showImportModal = false;
    private Node? editNode = null;
    private DotNetObjectReference<BlazorExecutionFlowGraph>? _dotNetRef;

    private string searchQuery = string.Empty;
    private string? selectedCategory = null;
    private int selectedNodeIndex = -1;
    private ElementReference searchInputRef;
    private ElementReference nodeListRef;

    private IEnumerable<string> Categories => _nodes
        .Select(n => n.Section)
        .Distinct()
        .OrderBy(s => s);

    private IEnumerable<string> MatchingCategories
    {
        get
        {
            if (string.IsNullOrWhiteSpace(searchQuery))
            {
                return Categories;
            }

            var query = searchQuery.ToLower();
            return _nodes
                .Where(n =>
                {
                    var originalName = n.BackingMethod.Name.ToLower();
                    var displayName = TypeHelpers.AddSpacesToPascalCase(n.Name).ToLower();
                    var section = n.Section.ToLower();

                    return ContainsFuzzy(displayName, query) ||
                           ContainsFuzzy(originalName, query) ||
                           section.Contains(query);
                })
                .Select(n => n.Section)
                .Distinct()
                .OrderBy(s => s);
        }
    }

    private string? EffectiveSelectedCategory
    {
        get
        {
            // If explicitly selected, use that
            if (selectedCategory != null)
                return selectedCategory;

            // If searching and only one section matches, auto-select it
            if (!string.IsNullOrWhiteSpace(searchQuery))
            {
                var matches = MatchingCategories.ToList();
                if (matches.Count == 1)
                    return matches[0];
            }

            return null;
        }
    }

    private IEnumerable<Node> FilteredNodes
    {
        get
        {
            var filtered = _nodes.AsEnumerable();

            // Filter by effective category
            var effectiveCategory = EffectiveSelectedCategory;
            if (effectiveCategory != null)
            {
                filtered = filtered.Where(n => n.Section == effectiveCategory);
            }

            // Then filter by search within that category
            if (!string.IsNullOrWhiteSpace(searchQuery))
            {
                var query = searchQuery.ToLower();
                filtered = filtered.Where(n =>
                {
                    var originalName = n.Name.ToLower();
                    var displayName = TypeHelpers.AddSpacesToPascalCase(n.Name).ToLower();

                    return ContainsFuzzy(displayName, query) ||
                           ContainsFuzzy(originalName, query);
                });
            }

            return filtered.OrderBy(n => n.Name);
        }
    }

    private bool ContainsFuzzy(string text, string pattern)
    {
        // Simple fuzzy match: all pattern chars must appear in order in text
        if (string.IsNullOrWhiteSpace(pattern)) return true;
        if (string.IsNullOrWhiteSpace(text)) return false;

        int patternIndex = 0;
        foreach (char c in text)
        {
            if (patternIndex < pattern.Length && c == pattern[patternIndex])
            {
                patternIndex++;
            }
        }
        return patternIndex == pattern.Length;
    }

    private string HighlightMatch(string text, string searchQuery)
    {
        if (string.IsNullOrWhiteSpace(searchQuery) || string.IsNullOrWhiteSpace(text))
            return text;

        var query = searchQuery.ToLower();
        var lowerText = text.ToLower();

        // Find the index of the search query in the text
        int index = lowerText.IndexOf(query);
        if (index >= 0)
        {
            var before = text.Substring(0, index);
            var match = text.Substring(index, query.Length);
            var after = text.Substring(index + query.Length);
            return $"{System.Net.WebUtility.HtmlEncode(before)}<mark class=\"search-highlight\">{System.Net.WebUtility.HtmlEncode(match)}</mark>{System.Net.WebUtility.HtmlEncode(after)}";
        }

        return System.Net.WebUtility.HtmlEncode(text);
    }

    private async Task HandleSearchKeyDown(KeyboardEventArgs e)
    {
        if (EffectiveSelectedCategory == null)
        {
            // We're showing sections
            var sections = MatchingCategories.ToList();

            if (e.Key == "ArrowDown")
            {
                if (sections.Any())
                {
                    selectedNodeIndex = (selectedNodeIndex + 1) % sections.Count;
                    await ScrollToSelectedNode();
                }
            }
            else if (e.Key == "ArrowUp")
            {
                if (sections.Any())
                {
                    selectedNodeIndex = selectedNodeIndex <= 0 ? sections.Count - 1 : selectedNodeIndex - 1;
                    await ScrollToSelectedNode();
                }
            }
            else if (e.Key == "Enter" && selectedNodeIndex >= 0 && selectedNodeIndex < sections.Count)
            {
                SelectSection(sections[selectedNodeIndex]);
            }
            else if (e.Key == "Escape")
            {
                ClearSearch();
            }
            else
            {
                // Reset selection when typing
                selectedNodeIndex = -1;
            }
        }
        else
        {
            // We're showing nodes within a section
            var filteredList = FilteredNodes.ToList();

            if (e.Key == "ArrowDown")
            {
                if (filteredList.Any())
                {
                    selectedNodeIndex = (selectedNodeIndex + 1) % filteredList.Count;
                    await ScrollToSelectedNode();
                }
            }
            else if (e.Key == "ArrowUp")
            {
                if (filteredList.Any())
                {
                    selectedNodeIndex = selectedNodeIndex <= 0 ? filteredList.Count - 1 : selectedNodeIndex - 1;
                    await ScrollToSelectedNode();
                }
            }
            else if (e.Key == "Enter" && selectedNodeIndex >= 0 && selectedNodeIndex < filteredList.Count)
            {
                await CreateNode(filteredList[selectedNodeIndex]);
                selectedNodeIndex = -1;
            }
            else if (e.Key == "Escape")
            {
                BackToSections();
            }
            else
            {
                // Reset selection when typing
                selectedNodeIndex = -1;
            }
        }
    }

    private async Task ScrollToSelectedNode()
    {
        try
        {
            await JS.InvokeVoidAsync("eval", $@"
                const container = document.querySelector('.node-list');
                const selected = container?.querySelector('.node-item.selected');
                if (selected && container) {{
                    const rect = selected.getBoundingClientRect();
                    const parentRect = container.getBoundingClientRect();
                    if (rect.top < parentRect.top || rect.bottom > parentRect.bottom) {{
                        selected.scrollIntoView({{ behavior: 'smooth', block: 'nearest' }});
                    }}
                }}
            ");
        }
        catch
        {
            // Silently ignore errors
        }
    }

    private void ClearSearch()
    {
        searchQuery = string.Empty;
        selectedCategory = null;
        selectedNodeIndex = -1;
    }

    private void SelectSection(string section)
    {
        selectedCategory = section;
        selectedNodeIndex = -1;
        searchQuery = string.Empty;
    }

    private void BackToSections()
    {
        selectedCategory = null;
        selectedNodeIndex = -1;
        searchQuery = string.Empty;
    }

    private async Task SaveChanges()
    {
        var currentUiNode = Graph.Nodes.First(x => x.Key == editNode.DrawflowNodeId);

        editNode.PosX = currentUiNode.Value.PosX;
        editNode.PosY = currentUiNode.Value.PosY;
        Graph.Nodes[editNode.DrawflowNodeId] = editNode;

        var json = DrawflowExporter.ExportToDrawflowJson(Graph.Nodes.Select(x => x.Value));
        await _base.CallAsync("import", json);

        await _base.JS.InvokeVoidAsync("nextFrame");

        foreach (var node in Graph.Nodes)
        {
            await _base.JS.InvokeVoidAsync("DrawflowBlazor.labelPorts", _base.Id, node.Value.DrawflowNodeId, new List<List<string>>(), node.Value.DeclaredOutputPorts.Select(x => new List<string>() { x, "" }));

            // Set node width based on title
            await _base.JS.InvokeVoidAsync("DrawflowBlazor.setNodeWidthFromTitle", _base.Id, node.Value.DrawflowNodeId);
        }

        // Update connection positions after import to prevent glitches
        await _base.JS.InvokeVoidAsync("DrawflowBlazor.updateConnectionNodes", _base.Id);

        AttachNodeEventHandlers();
    }

    private async Task ExecuteInputNodes()
    {
        await Graph.Run(new()
        {
            Parameters = WorkflowParameters.ToFrozenDictionary(),
            EnvironmentVariables = EnvironmentVariables.ToFrozenDictionary()
        }).ConfigureAwait(false);
    }

    async Task SetStatusAsync(string nodeId, bool isRunning, bool hasError = false, string? errorMessage = null, int? outputPos = null, object? value = null)
    {
        var status = new NodeStatus
        {
            IsRunning = isRunning,
            HasError = hasError,
            ErrorMessage = errorMessage
        };
        if (outputPos is not null)
        {
            status.OutputPortResults[outputPos.Value] = value!;
        }
        await _base.SetNodeStatus(nodeId, status);
    }

    void HandleNodeError(object? sender, NodeErrorEventArgs e)
    {
        if (!EnableStatusAnimations) return;

        _ = InvokeAsync(async () =>
        {
            await SetStatusAsync(e.Node.DrawflowNodeId, false, true, e.Message);
        });
        // Error is stored in the node, execution continues
    }

    /// <summary>
    /// Attaches event handlers to all nodes for status updates.
    /// This is critical for UI feedback - without it, status animations won't work.
    /// </summary>
    private void AttachNodeEventHandlers()
    {
        foreach (var node in Graph.Nodes)
        {
            // Remove any existing handlers first to avoid duplicates
            node.Value.OnStartExecuting -= HandleNodeStartExecuting;
            node.Value.OnStopExecuting -= HandleNodeStopExecuting;
            node.Value.OnError -= HandleNodeError;

            // Attach handlers
            node.Value.OnStartExecuting += HandleNodeStartExecuting;
            node.Value.OnStopExecuting += HandleNodeStopExecuting;
            node.Value.OnError += HandleNodeError;
        }
    }

    private readonly Dictionary<string, DateTime> _lastStatusUpdate = new();
    private readonly Dictionary<string, long> _statusSequence = new();
    private readonly Dictionary<string, (bool IsRunning, long Sequence)> _pendingStatusUpdates = new();
    private readonly SemaphoreSlim _batchLock = new(1, 1);
    private readonly TimeSpan _statusUpdateThrottle = TimeSpan.FromMilliseconds(50); // Max 20 updates/sec per node
    private readonly TimeSpan _batchWindow = TimeSpan.FromMilliseconds(10); // Batch updates within 10ms window
    private bool _batchScheduled = false;

    void HandleNodeStartExecuting(object? sender, EventArgs e)
    {
        if (!EnableStatusAnimations || sender is not Node node) return;

        // Throttle: Skip if we updated this node too recently
        if (_lastStatusUpdate.TryGetValue(node.DrawflowNodeId, out var lastUpdate))
        {
            if (DateTime.UtcNow - lastUpdate < _statusUpdateThrottle)
            {
                return; // Skip this update
            }
        }

        // Increment sequence number for this node
        if (!_statusSequence.ContainsKey(node.DrawflowNodeId))
            _statusSequence[node.DrawflowNodeId] = 0;

        var sequence = ++_statusSequence[node.DrawflowNodeId];
        _lastStatusUpdate[node.DrawflowNodeId] = DateTime.UtcNow;

        // Add to batch instead of calling immediately
        lock (_pendingStatusUpdates)
        {
            _pendingStatusUpdates[node.DrawflowNodeId] = (true, sequence);
        }

        ScheduleBatchUpdate();
    }

    void HandleNodeStopExecuting(object? sender, EventArgs e)
    {
        if (!EnableStatusAnimations || sender is not Node node) return;

        // Increment sequence number for this node
        if (!_statusSequence.ContainsKey(node.DrawflowNodeId))
            _statusSequence[node.DrawflowNodeId] = 0;

        var sequence = ++_statusSequence[node.DrawflowNodeId];
        _lastStatusUpdate[node.DrawflowNodeId] = DateTime.UtcNow;

        // Add to batch instead of calling immediately
        lock (_pendingStatusUpdates)
        {
            _pendingStatusUpdates[node.DrawflowNodeId] = (false, sequence);
        }

        ScheduleBatchUpdate();

        // Update port status with computed results
        if (node.Result != null && !node.HasError)
        {
            _ = InvokeAsync(async () =>
            {
                var status = new NodeStatus
                {
                    IsRunning = false,
                    HasError = false
                };


                if (!node.IsPortDriven)
                {
                    for (int i = 0; i < Math.Max(node.DeclaredOutputPorts.Count, 1); i++)
                    {
                        status.OutputPortResults[i] = node.Result.ToJsonString();
                    }
                    
                }

                await this.SetNodeStatus(node.DrawflowNodeId, status);
            });
        }
    }

    private void ScheduleBatchUpdate()
    {
        lock (_pendingStatusUpdates)
        {
            if (_batchScheduled) return;
            _batchScheduled = true;
        }

        // Fire and forget: schedule batch processing after a short delay
        _ = Task.Run(async () =>
        {
            await Task.Delay(_batchWindow);
            await ProcessBatchUpdates();
        });
    }

    private async Task ProcessBatchUpdates()
    {
        Dictionary<string, (bool IsRunning, long Sequence)> batch;

        lock (_pendingStatusUpdates)
        {
            if (_pendingStatusUpdates.Count == 0)
            {
                _batchScheduled = false;
                return;
            }

            // Copy and clear pending updates
            batch = new Dictionary<string, (bool, long)>(_pendingStatusUpdates);
            _pendingStatusUpdates.Clear();
            _batchScheduled = false;
        }

        // Marshal to UI thread once for the entire batch
        await InvokeAsync(async () =>
        {
            // Build array of status updates for bulk JS call
            var statusUpdates = batch
                .Where(kvp => _statusSequence.TryGetValue(kvp.Key, out var currentSeq) && kvp.Value.Sequence <= currentSeq)
                .Select(kvp => new
                {
                    nodeId = kvp.Key,
                    isRunning = (bool?)kvp.Value.IsRunning,
                    hasError = (bool?)null,
                    errorMessage = (string?)null
                })
                .ToArray();

            // Single bulk JS call instead of individual calls
            if (statusUpdates.Length > 0)
            {
                await JS.InvokeVoidAsync("DrawflowBlazor.setBulkNodeStatus", ElementId, statusUpdates);
            }
        });
    }

    private async Task Run()
    {
        _ = Graph.Run(new()
        {
            Parameters = WorkflowParameters.ToFrozenDictionary(),
            EnvironmentVariables = EnvironmentVariables.ToFrozenDictionary()
        }).ConfigureAwait(false);
    }

    private async Task CreateNode(Node nodeTemplate)
    {
        var node = DrawflowHelpers.CreateNodeFromMethod(nodeTemplate.BackingMethod);
        var returnProps = TypeHelpers.GetReturnProperties(node.BackingMethod);
        node.ParentWorkflowId = nodeTemplate.ParentWorkflowId;
        node.NameOverride = nodeTemplate.NameOverride;

        if (returnProps?.Count > 0)
        {
            node.MethodOutputToNodeOutputMap = MappingHelpers.GenerateSmartOutputMappings(node.BackingMethod, returnProps);
        }

        var random = new Random();

        // Use smart mapping helper to generate intelligent default output mappings
        node.PosX = PosX + 60 + (30 * random.NextDouble());
        node.PosY = PosY + 60 + (30 * random.NextDouble());
        if (node.ParentWorkflowId is not null &&
            node.IsWorkflowNode)
        {
            var workflow = _workflowService.GetWorkflow(node.ParentWorkflowId);
            node.NodeInputToMethodInputMap = WorkflowInputDiscovery.DiscoverInputs(workflow.FlowGraph)
                                                .Select(x => new PathMapEntry() { To = x })
                                                .ToList();
        }
        else
        {
            node.NodeInputToMethodInputMap = MappingHelpers.GenerateDefaultInputMappings(node.BackingMethod);
        }

        node.DrawflowNodeId = (await _base.CreateNodeV2(node, "ƒ")).ToString();
        Graph.Nodes[node.DrawflowNodeId] = node;

        // Attach event handlers to new node
        AttachNodeEventHandlers();
    }

    private async Task HandleEvent(DrawflowEventArgs e)
    {
        await InvokeAsync(StateHasChanged);
    }

    private async Task DoubleClickedNode(string nodeId)
    {
        var node = Graph.Nodes.FirstOrDefault(x => x.Key == nodeId.ToString());

        if (node.Value != null && node.Value.Section != "Events")
        {
            editNode = node.Value;
            showModal = true;
        }

        await InvokeAsync(StateHasChanged);
    }

    private void CloseModalAfterUndoRedo()
    {
        showModal = false;
        editNode = null;
    }

    protected override void OnInitialized()
    {
        _nodes = DrawflowHelpers.GetNodesObjectsV2();
        var workflowNodes = _workflowService
            .GetAllWorkflows()
            .Where(x => x.IncludeAsNode)
            .Select(x => CreateNodeFromWorkflow(x));

		_nodes.AddRange(workflowNodes);

        _base = this;

        // Set up callback to close modal after undo/redo
        OnCloseModalAfterUndoRedo = CloseModalAfterUndoRedo;

        // Set up callback to attach node event handlers after undo/redo
        OnAttachNodeEventHandlers = AttachNodeEventHandlers;

        base.OnInitialized();
    }

    private async Task Export()
    {
        if (_base is null) return;
        var exported = await _base.CallAsync<object>("export");
        _exportJson = System.Text.Json.JsonSerializer.Serialize(exported, new System.Text.Json.JsonSerializerOptions { WriteIndented = true });
    }

    private async Task ExportCSharp()
    {
        if (_base is null) return;
        var nodes = Graph.Nodes.Select(x => x.Value).ToList();
        _exportJson = FlowSerializer.SerializeFlow(nodes);
    }

    private async Task ImportCSharp()
    {
        if (_base is null || string.IsNullOrWhiteSpace(_importJson)) return;

        try
        {
            _importError = null;
            var nodes = FlowSerializer.DeserializeFlow(_importJson);

            // Clear existing graph
            await _base.CallAsync<object>("clear");

            // Update Graph.Nodes to match imported nodes
            Graph.Nodes.Clear();
            foreach (var node in nodes)
            {
                Graph.Nodes[node.DrawflowNodeId] = node;
            }

            // Import nodes to drawflow
            var json = DrawflowExporter.ExportToDrawflowJson(nodes);
            await _base.CallAsync("import", json);
            await _base.JS.InvokeVoidAsync("nextFrame");

            // Re-apply port labels for nodes with multiple outputs
            foreach (var node in nodes)
            {
                await _base.JS.InvokeVoidAsync("DrawflowBlazor.labelPorts", _base.Id, node.DrawflowNodeId, new List<List<string>>(), node.DeclaredOutputPorts.Select(x => new List<string>() { x, "" }));

                // Set node width based on title
                await _base.JS.InvokeVoidAsync("DrawflowBlazor.setNodeWidthFromTitle", _base.Id, node.DrawflowNodeId);
            }

            // Update connection positions after import to prevent glitches
            await _base.JS.InvokeVoidAsync("DrawflowBlazor.updateConnectionNodes", _base.Id);

            AttachNodeEventHandlers();

            showImportModal = false;
            _importJson = null;
        }
        catch (Exception ex)
        {
            _importError = $"Import failed: {ex.Message}";
        }
    }

    private async Task CopyToClipboard()
    {
        if (_base is null || string.IsNullOrWhiteSpace(_exportJson)) return;
        await _base.JS.InvokeVoidAsync("navigator.clipboard.writeText", _exportJson);
    }

    private async Task Clear()
    {
        if (_base is null) return;
        await _base.CallAsync<object>("clear");
        _exportJson = null;

        // Clear the Graph nodes
        Graph.Nodes.Clear();

        // Add a default Start node
        var startMethod = typeof(CoreNodes).GetMethod(nameof(CoreNodes.Start));
        if (startMethod != null)
        {
            var startNode = DrawflowHelpers.CreateNodeFromMethod(startMethod);
            startNode.PosX = 50;
            startNode.PosY = 50;
            startNode.NodeInputToMethodInputMap = MappingHelpers.GenerateDefaultInputMappings(startNode.BackingMethod);

            startNode.DrawflowNodeId = (await _base.CreateNodeV2(startNode, "ƒ")).ToString();
            Graph.Nodes[startNode.DrawflowNodeId] = startNode;

            // Attach event handlers to the new node
            AttachNodeEventHandlers();

            // Update connection positions
            await _base.JS.InvokeVoidAsync("DrawflowBlazor.updateConnectionNodes", _base.Id).ConfigureAwait(false);
        }
    }

    /// <summary>
    /// Loads a workflow from serialized JSON data.
    /// </summary>
    public async Task LoadFromJson(string flowJson)
    {
        if (_base is null || string.IsNullOrWhiteSpace(flowJson)) return;

        try
        {
            var nodes = FlowSerializer.DeserializeFlow(flowJson);

            // Clear existing graph
            await _base.CallAsync<object>("clear");

            // Import nodes to drawflow
            var json = DrawflowExporter.ExportToDrawflowJson(nodes);
            await _base.CallAsync("import", json);
            await _base.JS.InvokeVoidAsync("nextFrame");

            // Update Graph.Nodes to match imported nodes
            Graph.Nodes.Clear();
            foreach (var node in nodes)
            {
                Graph.Nodes[node.DrawflowNodeId] = node;
            }

            // Re-apply port labels for nodes with multiple outputs
            foreach (var node in nodes)
            {
                await _base.JS.InvokeVoidAsync("DrawflowBlazor.labelPorts", _base.Id, node.DrawflowNodeId, new List<List<string>>(), node.DeclaredOutputPorts.Select(x => new List<string>() { x, "" }));

                // Set node width based on title
                await _base.JS.InvokeVoidAsync("DrawflowBlazor.setNodeWidthFromTitle", _base.Id, node.DrawflowNodeId);
            }

            // Update connection positions after import to prevent glitches
            await _base.JS.InvokeVoidAsync("DrawflowBlazor.updateConnectionNodes", _base.Id);

            // Attach event handlers to loaded nodes
            AttachNodeEventHandlers();
        }
        catch (Exception ex)
        {
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await base.OnAfterRenderAsync(firstRender);

        if (!firstRender) return;

        _dotNetRef = DotNetObjectReference.Create(this);

        await JS.InvokeVoidAsync(
            "window.DrawflowBlazor.setNodeDoubleClickCallback",
            ElementId,
            _dotNetRef
        );

        // Attach event handlers to all nodes for status updates
        // This is CRITICAL for UI feedback (pulsing animations, error states, etc.)
        AttachNodeEventHandlers();
    }

    [JSInvokable]
    public async Task OnNodeDoubleClickFromJs(string nodeId)
    {
        if (OnNodeDoubleClicked.HasDelegate)
        {
            await OnNodeDoubleClicked.InvokeAsync(nodeId);
        }

        await DoubleClickedNode(nodeId);
    }


    public void Dispose()
    {
        _dotNetRef?.Dispose();
    }
}
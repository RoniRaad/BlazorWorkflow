@using System.Reflection
@using BlazorExecutionFlow.Helpers
@using BlazorExecutionFlow.Models.NodeV2
@using Microsoft.AspNetCore.Components.Forms
@using System.Text.Json
@using System.Text.Json.Nodes
@using System.Net.Http
@using System.Net.Http.Json
@using Microsoft.AspNetCore.Components.Routing
@using Microsoft.AspNetCore.Components.Web
@using static Microsoft.AspNetCore.Components.Web.RenderMode
@using Microsoft.AspNetCore.Components.Web.Virtualization
@using Microsoft.JSInterop
@using Scriban
@using Scriban.Runtime
@inject IJSRuntime JSRuntime
@implements IDisposable

<!-- Modal Backdrop -->
<div class="modal-backdrop fade show" @onclick="HandleBackdropClick"></div>

<!-- Node editor modal -->
<div style="display:block;" class="bef-lib modal fade show node-editor-modal"
id="nodeEditorModal"
tabindex="-1"
aria-labelledby="nodeEditorLabel"
aria-modal="true"
role="dialog"
@onkeydown="HandleKeyDown">
    <div class="modal-dialog node-editor-dialog">
        <div class="modal-content node-editor-content">
            <div class="modal-header node-editor-header">
                <button type="button"
                        class="btn-close-modal"
                        @onclick="HandleClose"
                        title="Close modal">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
                        <line x1="18" y1="6" x2="6" y2="18"></line>
                        <line x1="6" y1="6" x2="18" y2="18"></line>
                    </svg>
                </button>
                <div class="node-title-container">
                    @if (_isEditingNodeName)
                    {
                        <input type="text"
                               class="node-name-input"
                               @bind="_editingNodeName"
                               @bind:event="oninput"
                               @onblur="SaveNodeName"
                               @onkeydown="HandleNodeNameKeyDown"
                               @ref="_nodeNameInputRef"
                               placeholder="Node name..." />
                    }
                    else
                    {
                        <div class="node-name-display">
                            <h5 class="modal-title" id="nodeEditorLabel" @onclick="StartEditingNodeName">
                                @(BackingNode?.NameOverride ?? BackingNode?.Name ?? "Unknown")
                            </h5>
                            <button type="button" class="btn-edit-node-name" @onclick="StartEditingNodeName" title="Edit node name">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                                    <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                                </svg>
                            </button>
                        </div>
                        @if (!string.IsNullOrEmpty(BackingNode?.NameOverride))
                        {
                            <p class="node-type-subtitle">Type: @(TypeHelpers.AddSpacesToPascalCase(BackingNode?.BackingMethod?.Name) ?? BackingNode?.Name ?? "Unknown")</p>
                        }
                    }
                </div>
                <button type="button"
                class="btn-execute-flow"
                @onclick="ExecuteInput"
                disabled="@isExecuting"
                data-role="execute-input"
                title="Execute Flow">
                    @if (isExecuting)
                    {
                        <span class="spinner-border" role="status" aria-hidden="true" style="width: 2.5rem; height: 2.5rem;"></span>
                    }
                    else
                    {
                        <svg viewBox="0 0 24 24" fill="currentColor" style="width: 2.5rem; height: 2.5rem;">
                            <path d="M8 5v14l11-7z"/>
                        </svg>
                    }
                </button>
            </div>

            <!-- Error Alert -->
            @if (BackingNode?.HasError == true && !_errorDismissed)
            {
                <div class="alert alert-danger node-error-alert" role="alert">
                    <div class="error-header">
                        <svg class="error-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="12" cy="12" r="10"></circle>
                            <line x1="12" y1="8" x2="12" y2="12"></line>
                            <line x1="12" y1="16" x2="12.01" y2="16"></line>
                        </svg>
                        <strong>Execution Error</strong>
                        <button type="button" class="error-dismiss-btn" @onclick="DismissError" title="Dismiss error">
                            ✕
                        </button>
                    </div>
                    <p class="error-message">@BackingNode.ErrorMessage</p>
                    @if (BackingNode.LastException != null)
                    {
                        <details class="error-details">
                            <summary>View stack trace</summary>
                            <pre class="error-stack">@BackingNode.LastException.StackTrace</pre>
                        </details>
                    }
                </div>
            }

            <div class="modal-body node-editor-body">
                <div class="node-editor-grid">
                    <!-- INPUT PANEL -->
                    <section class="node-editor-panel node-editor-panel-input">
                        <header class="panel-header">
                            <h6>Incoming payload</h6>
                            <p class="panel-caption">Preview the payload that arrives at this node.</p>
                        </header>
                        <div class="panel-body">
                            <!-- Search and Filter Controls -->
                            <div class="json-controls">
                                <input type="text"
                                       class="form-control form-control-sm json-search"
                                       placeholder="Search in JSON..."
                                       @bind="_jsonSearchTerm"
                                       @bind:event="oninput"
                                       data-role="json-search" />
                                <select class="form-select form-select-sm json-filter"
                                        @bind="_jsonFilterMode"
                                        data-role="json-filter">
                                    @foreach (var filter in GetAvailableFilters())
                                    {
                                        <option value="@filter.Key">@filter.Value</option>
                                    }
                                    <option value="all">All</option>
                                </select>
                            </div>

                            <div class="payload-preview draggable-json selectable-json" data-role="payload-preview">
                                @RenderDraggableJson(GetFilteredJson(), "")
                            </div>
                        </div>
                    </section>

                    <!-- PROCESSING PANEL -->
                    <section class="node-editor-panel node-editor-panel-processing">
                        <header class="panel-header">
                            <h6>Function mapping</h6>
                            <p class="panel-caption">Map payload fields into your function and back out again.</p>
                        </header>

                        <div class="panel-body panel-body-scroll">
                            <!-- Function input map -->
                            <div class="panel-section" data-role="function-input-map">
                                <div class="panel-section-header">
                                    <span>Function inputs</span>
                                </div>

                                <div class="simple-mapping-list" data-role="input-mapping-list">
                                    @foreach (var inputMapping in ViewModel.NodeInputToMethodInputMap)
                                    {
                                        var param = GetParameterInfo(inputMapping.To);
                                        var formattedType = param != null ? FormatTypeName(param.ParameterType) : "unknown";
                                        <div class="simple-mapping-item" data-role="input-mapping-row">
                                            <label class="simple-mapping-label" title="@formattedType">
                                                @inputMapping.To
                                                @if (param != null)
                                                {
                                                    <span class="param-type-hint">(@formattedType)</span>
                                                }
                                            </label>
                                            <div class="input-with-preview">
                                                <textarea value="@inputMapping.From"
                                                          @oninput="@((e) => { inputMapping.From = e.Value?.ToString() ?? ""; TriggerAutoSave(); })"
                                                          class="form-control form-control-sm droppable-input mapping-input"
                                                          placeholder="e.g. input.name or {{input.name}}"
                                                          aria-label="Scriban template for @inputMapping.To"
                                                          @ondragover="@((e) => HandleDragOver(e))"
                                                          @ondragover:preventDefault="true"
                                                          @ondrop="@((e) => HandleDrop(e, inputMapping))"
                                                          style="padding-right: 15px"
                                                          rows="1"
                                                          required
                                                          data-role="payload-path"></textarea>
                                                <div class="preview-button-container" style="top: -5px;position: absolute;right: -9px;">
                                                    <button type="button"
                                                            class="btn-preview"
                                                            style="background-color: transparent;border: transparent;color: white;"
                                                            @onclick="@((e) => TogglePreview(inputMapping, e))"
                                                            @onclick:stopPropagation="true"
                                                            title="Toggle preview">
                                                        👁
                                                    </button>
                                                    @if (_previewMapping == inputMapping)
                                                    {
                                                        <div class="preview-popover">
                                                            <div class="preview-popover-arrow"></div>
                                                            <div class="preview-popover-content">
                                                                <div class="preview-popover-label">Preview</div>
                                                                <div class="preview-popover-value">@GetScribanPreviewValue(inputMapping)</div>
                                                            </div>
                                                        </div>
                                                    }
                                                </div>
                                            </div>
                                        </div>
                                    }
                                </div>
                            </div>

                            <!-- Dictionary Parameters -->
                            @{
                                var dictParams = GetDictionaryParameters().ToList();
                            }
                            @if (dictParams.Any())
                            {
                                <hr class="panel-divider" />

                                @foreach (var dictParam in dictParams)
                                {
                                    <div class="panel-section" data-role="dictionary-parameter-map">
                                        <div class="panel-section-header">
                                            <span>@dictParam.Name</span>
                                            <button onclick="@(() => AddDictionaryEntry(dictParam.Name ?? string.Empty))" type="button"
                                                    class="btn-add-entry"
                                                    data-role="add-dictionary-entry">
                                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                                    <line x1="12" y1="5" x2="12" y2="19"></line>
                                                    <line x1="5" y1="12" x2="19" y2="12"></line>
                                                </svg>
                                                Add entry
                                            </button>
                                        </div>

                                        <div class="mapping-list" data-role="dictionary-entry-list">
                                            @{
                                                if (!ViewModel.DictionaryParameterMappings.ContainsKey(dictParam.Name ?? string.Empty))
                                                {
                                                    ViewModel.DictionaryParameterMappings[dictParam.Name ?? string.Empty] = new List<PathMapEntry>();
                                                }

                                                var entries = ViewModel.DictionaryParameterMappings[dictParam.Name ?? string.Empty];
                                            }

                                            @foreach (var entry in entries)
                                            {
                                                <div class="mapping-row" data-role="dictionary-entry-row">
                                                    <div class="mapping-col">
                                                        <label>Key</label>
                                                        <input value="@entry.To"
                                                               @oninput="@((e) => { entry.To = e.Value?.ToString() ?? ""; TriggerAutoSave(); })"
                                                               type="text"
                                                               class="form-control mapping-input"
                                                               placeholder="e.g. Authorization, Content-Type"
                                                               aria-label="Key"
                                                               data-role="dictionary-key" />
                                                    </div>
                                                    <div class="mapping-arrow">→</div>
                                                    <div class="mapping-col">
                                                        <label>Value</label>
                                                        <input value="@entry.From"
                                                               @oninput="@((e) => { entry.From = e.Value?.ToString() ?? ""; TriggerAutoSave(); })"
                                                               type="text"
                                                               class="form-control mapping-input droppable-input"
                                                               placeholder="e.g. input.token or {{input.token}}"
                                                               aria-label="Dictionary value"
                                                               @ondragover="@((e) => HandleDragOver(e))"
                                                               @ondragover:preventDefault="true"
                                                               @ondrop="@((e) => HandleDrop(e, entry))"
                                                               data-role="dictionary-value" />
                                                    </div>
                                                    <button onclick="@(() => RemoveDictionaryEntry(dictParam.Name ?? string.Empty, entry))"
                                                            type="button"
                                                            class="btn btn-icon btn-xs"
                                                            aria-label="Remove dictionary entry"
                                                            title="Remove this dictionary entry"
                                                            data-role="remove-dictionary-entry">
                                                        <span aria-hidden="true">✕</span>
                                                    </button>
                                                </div>
                                            }
                                        </div>
                                    </div>
                                }
                            }

                            <hr class="panel-divider" />

                            <!-- Function output map -->
                            @if (BackingNode.DeclaredOutputPorts.Count == 0)
                            {
                                <div class="panel-section" data-role="function-output-map">
                                    <div class="panel-section-header">
                                        <span>Function outputs</span>
                                    </div>

                                    <div class="simple-mapping-list" data-role="output-mapping-list">
                                        @{ var propInfos = GetReturnProperties(); }
                                        @if (propInfos is not null)
                                        {
                                            @foreach (var outputMapping in ViewModel.MethodOutputToNodeOutputMap)
                                            {
                                                var propInfo = propInfos.FirstOrDefault(p => p.Name == outputMapping.From);
                                                var hasProperty = !string.IsNullOrEmpty(propInfo.Name);
                                                var typeDisplay = hasProperty ? propInfo.Type : TypeHelpers.FormatTypeName(BackingNode.BackingMethod.ReturnType);
                                                <div class="simple-mapping-item" data-role="output-mapping-row">
                                                    <div class="simple-mapping-label-row">
                                                        <label class="simple-mapping-label" title="@typeDisplay">
                                                            @outputMapping.From
                                                            <span class="param-type-hint">(@typeDisplay)</span>
                                                        </label>
                                                        <label class="workflow-output-checkbox-label" title="Expose this output to workflow.output.*">
                                                            <InputCheckbox Value="@outputMapping.ExposeAsWorkflowOutput"
                                                                           ValueChanged="@((bool value) => { outputMapping.ExposeAsWorkflowOutput = value; TriggerAutoSave(); })"
                                                                           ValueExpression="@(() => outputMapping.ExposeAsWorkflowOutput)"
                                                                           class="workflow-output-checkbox"
                                                                           data-role="expose-workflow-output" />
                                                            <span class="workflow-output-checkbox-text">Workflow output</span>
                                                        </label>
                                                    </div>
                                                    <InputTextArea @bind-Value="outputMapping.To"
                                                                   @oninput="@(() => TriggerAutoSave())"
                                                                   class="form-control form-control-sm mapping-input"
                                                                   placeholder="e.g. output.name"
                                                                   required
                                                                   rows="1"
                                                                   data-role="target-payload-path" />
                                                </div>
                                            }
                                        }
                                    </div>
                                </div>
                            }
                            else
                            {
                                <!-- Port-driven nodes don't use output mappings -->
                                <div class="panel-section" data-role="port-driven-info">
                                    <div class="alert alert-info" style="margin: 0;">
                                        <strong>Port-Driven Node</strong>
                                        <p style="margin: 0.5rem 0 0 0; font-size: 0.875rem;">
                                            This node uses port-driven execution with outputs: <strong>@string.Join(", ", BackingNode.DeclaredOutputPorts)</strong>
                                        </p>
                                        <p style="margin: 0.5rem 0 0 0; font-size: 0.875rem; color: #666;">
                                            Data provided by this node varies by port. Output mappings are not used—downstream nodes receive data automatically based on which port they're connected to.
                                        </p>
                                    </div>
                                </div>
                            }
                        </div>
                    </section>

                    <!-- OUTPUT PANEL -->
                    <section class="node-editor-panel node-editor-panel-output">
                        <header class="panel-header">
                            <h6>Resulting payload</h6>
                            <p class="panel-caption">See what leaves this node after mappings.</p>
                        </header>
                        <div class="panel-body">
                            <div class="payload-preview payload-preview--output selectable-json"
                                 data-role="output-preview">
                                @RenderSelectableJson(OutputPayloadJson, "")
                            </div>
                        </div>
                    </section>
                </div>
            </div>
        </div>
    </div>
</div>

@code {
    [Parameter]
    public EventCallback CloseRequested { get; set; }

    [Parameter]
    public EventCallback SaveRequested { get; set; }

    [Parameter]
    public EventCallback ExecuteInputRequested { get; set; }

    [Parameter]
    public required Node BackingNode { get; set; } = new() { BackingMethod = null };

    [Parameter]
    public JsonNode? IncomingPayloadJson { get; set; }

    [Parameter]
    public JsonNode? OutputPayloadJson { get; set; }

    public NodeEditorModalViewModel ViewModel { get; set; } = new();
    private bool isSaving = false;
    private bool saveSuccess = false;
    private bool isExecuting = false;
    private string? _draggedFieldPath = null;
    private PathMapEntry? _previewMapping = null;
    private ElementReference _previewButtonRef;
    private ElementReference _previewPopoverRef;
    private bool _errorDismissed = false;
    private string? _lastErrorMessage = null;

    // Auto-save debouncing
    private System.Threading.Timer? _autoSaveTimer;
    private readonly int _autoSaveDelayMs = 500; // 500ms debounce

    // JSON preview controls
    private string _jsonSearchTerm = "";
    private string _jsonFilterMode = "Input";

    // Filter registry - register filters by name for easy extensibility
    private readonly Dictionary<string, JsonFilter> _filterRegistry = new();

    // Node name editing
    private bool _isEditingNodeName = false;
    private string _editingNodeName = "";
    private ElementReference _nodeNameInputRef;

    protected override void OnInitialized()
    {
        base.OnInitialized();

        // Register all available filters
        // To add a new filter: _filterRegistry.Add("filtername", FilterMethod);
        _filterRegistry.Add("search", SearchFilter);
        _filterRegistry.Add("Input", InputOnlyFilter);
        _filterRegistry.Add("Environment", EnvironmentOnlyFilter);
        _filterRegistry.Add("Workflow", GlobalOnlyFilter);
        _filterRegistry.Add("Nodes", NodeOnlyFilter);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Add event listener for tab key and auto-resize for textareas
            await JSRuntime.InvokeVoidAsync("eval", @"
                // Auto-resize function
                function autoResizeTextarea(textarea) {
                    textarea.style.height = 'auto';
                    textarea.style.height = textarea.scrollHeight + 'px';
                }

                // Tab key handler
                document.addEventListener('keydown', function(e) {
                    if (e.key === 'Tab' && e.target.tagName === 'TEXTAREA' && e.target.closest('.node-editor-modal')) {
                        e.preventDefault();
                        var textarea = e.target;

                        // Use execCommand if available (preserves undo history), otherwise fallback
                        if (document.execCommand) {
                            document.execCommand('insertText', false, '\t');
                        } else {
                            // Fallback for browsers that don't support execCommand
                            var start = textarea.selectionStart;
                            var end = textarea.selectionEnd;
                            var value = textarea.value;
                            textarea.value = value.substring(0, start) + '\t' + value.substring(end);
                            textarea.selectionStart = textarea.selectionEnd = start + 1;
                        }

                        textarea.dispatchEvent(new Event('input', { bubbles: true }));
                        autoResizeTextarea(textarea);
                    }
                }, true);

                // Input handler for auto-resize
                document.addEventListener('input', function(e) {
                    if (e.target.tagName === 'TEXTAREA' && e.target.closest('.node-editor-modal')) {
                        autoResizeTextarea(e.target);
                    }
                }, true);

                // Initial resize for all textareas in modal
                var textareas = document.querySelectorAll('.node-editor-modal textarea');
                textareas.forEach(function(textarea) {
                    autoResizeTextarea(textarea);
                });

                // Also observe for new textareas being added (for dynamic content)
                var observer = new MutationObserver(function(mutations) {
                    mutations.forEach(function(mutation) {
                        mutation.addedNodes.forEach(function(node) {
                            if (node.nodeType === 1) {
                                if (node.tagName === 'TEXTAREA' && node.closest('.node-editor-modal')) {
                                    autoResizeTextarea(node);
                                }
                                var textareas = node.querySelectorAll ? node.querySelectorAll('textarea') : [];
                                textareas.forEach(function(textarea) {
                                    if (textarea.closest('.node-editor-modal')) {
                                        autoResizeTextarea(textarea);
                                    }
                                });
                            }
                        });
                    });
                });

                var modalContainer = document.querySelector('.node-editor-modal');
                if (modalContainer) {
                    observer.observe(modalContainer, { childList: true, subtree: true });
                }
            ");
        }
    }

    protected override void OnParametersSet()
    {
        base.OnParametersSet();

        // Create a fresh ViewModel each time to avoid stale data
        ViewModel = new NodeEditorModalViewModel();
        ViewModel.NodeInputToMethodInputMap = BackingNode.NodeInputToMethodInputMap;
        ViewModel.MethodOutputToNodeOutputMap = BackingNode.MethodOutputToNodeOutputMap;
        ViewModel.DictionaryParameterMappings = new Dictionary<string, List<PathMapEntry>>(BackingNode.DictionaryParameterMappings);

        OutputPayloadJson = BackingNode?.Result;
        IncomingPayloadJson = BackingNode?.Input;

        // Reset error dismissed state when a new error occurs
        if (BackingNode?.HasError == true && BackingNode.ErrorMessage != _lastErrorMessage)
        {
            _errorDismissed = false;
            _lastErrorMessage = BackingNode.ErrorMessage;
        }
        else if (BackingNode?.HasError == false)
        {
            // Clear tracking when there's no error
            _lastErrorMessage = null;
        }
    }

    /// <summary>
    /// Checks if a type is a collection type (List, Array, IEnumerable, etc.)
    /// </summary>
    private bool IsCollectionType(Type? returnType, string? typeName)
    {
        if (returnType == null)
            return false;

        // Unwrap Task<T> if needed
        if (returnType.IsGenericType && returnType.GetGenericTypeDefinition() == typeof(Task<>))
        {
            returnType = returnType.GetGenericArguments()[0];
        }

        // Check if it's an array
        if (returnType.IsArray)
            return true;

        // Check if it's a generic collection (List<T>, IEnumerable<T>, etc.)
        if (returnType.IsGenericType)
        {
            var genericDef = returnType.GetGenericTypeDefinition();
            return genericDef == typeof(List<>) ||
                   genericDef == typeof(IEnumerable<>) ||
                   genericDef == typeof(ICollection<>) ||
                   genericDef == typeof(IList<>);
        }

        // Check by type name as fallback (in case typeName contains "List", "Array", etc.)
        if (!string.IsNullOrEmpty(typeName))
        {
            var lowerType = typeName.ToLowerInvariant();
            return lowerType.Contains("list") ||
                   lowerType.Contains("array") ||
                   lowerType.Contains("collection") ||
                   lowerType.Contains("enumerable");
        }

        return false;
    }

    private bool IsCollectionOutputName(string name)
    {
        return name == "results" || name == "items" || name == "collection" ||
               name == "list" || name == "array" || name == "data";
    }

    private bool IsSingularOutputName(string name)
    {
        return name == "result" || name == "item" || name == "value" ||
               name == "output" || name == "data";
    }

    /// <summary>
    /// Checks if a type is a boolean type
    /// </summary>
    private bool IsBooleanType(Type? returnType, string? typeName)
    {
        if (returnType == null)
            return false;

        // Unwrap Task<T> if needed
        if (returnType.IsGenericType && returnType.GetGenericTypeDefinition() == typeof(Task<>))
        {
            returnType = returnType.GetGenericArguments()[0];
        }

        // Check if it's a bool
        if (returnType == typeof(bool) || returnType == typeof(bool?))
            return true;

        // Check by type name as fallback
        if (!string.IsNullOrEmpty(typeName))
        {
            var lowerType = typeName.ToLowerInvariant();
            return lowerType.Contains("boolean") || lowerType == "bool";
        }

        return false;
    }

    /// <summary>
    /// Checks if a type is a string type
    /// </summary>
    private bool IsStringType(Type? returnType, string? typeName)
    {
        if (returnType == null)
            return false;

        // Unwrap Task<T> if needed
        if (returnType.IsGenericType && returnType.GetGenericTypeDefinition() == typeof(Task<>))
        {
            returnType = returnType.GetGenericArguments()[0];
        }

        // Check if it's a string
        if (returnType == typeof(string))
            return true;

        // Check by type name as fallback
        if (!string.IsNullOrEmpty(typeName))
        {
            var lowerType = typeName.ToLowerInvariant();
            return lowerType == "string";
        }

        return false;
    }

    private bool IsStringOutputName(string name)
    {
        return name == "text" || name == "message" || name == "content" ||
               name == "str" || name == "description";
    }

    /// <summary>
    /// Checks if a type is an integer type
    /// </summary>
    private bool IsIntegerType(Type? returnType, string? typeName)
    {
        if (returnType == null)
            return false;

        // Unwrap Task<T> if needed
        if (returnType.IsGenericType && returnType.GetGenericTypeDefinition() == typeof(Task<>))
        {
            returnType = returnType.GetGenericArguments()[0];
        }

        // Check if it's an integer type
        if (returnType == typeof(int) || returnType == typeof(int?) ||
            returnType == typeof(long) || returnType == typeof(long?) ||
            returnType == typeof(short) || returnType == typeof(short?) ||
            returnType == typeof(byte) || returnType == typeof(byte?))
            return true;

        // Check by type name as fallback
        if (!string.IsNullOrEmpty(typeName))
        {
            var lowerType = typeName.ToLowerInvariant();
            return lowerType == "int32" || lowerType == "int64" ||
                   lowerType == "int16" || lowerType == "byte" ||
                   lowerType == "integer" || lowerType == "int";
        }

        return false;
    }

    private bool IsIntegerOutputName(string name)
    {
        return name == "count" || name == "number" || name == "length" ||
               name == "size" || name == "total" || name == "index";
    }

    private string GeneratePlaceholderLiteral(Type paramType, string? paramName)
    {
        // Generate helpful placeholder values based on type
        if (paramType == typeof(string))
            return $"\"\"";  // Empty string placeholder
        if (paramType == typeof(int))
            return "0";
        if (paramType == typeof(double) || paramType == typeof(float))
            return "0.0";
        if (paramType == typeof(bool))
            return "false";
        if (paramType == typeof(DateTime))
            return $"\"{DateTime.Now:yyyy-MM-dd}\"";

        // For other types, try to provide a sensible default
        return "\"\"";
    }

    public List<(string? Type, string? Name)>? GetReturnProperties()
    {
        return TypeHelpers.GetReturnProperties(BackingNode.BackingMethod);
    }

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Escape" && !isSaving)
        {
            await HandleClose();
        }
    }

    private async Task HandleClose()
    {
        if (isSaving) return;
        await CloseRequested.InvokeAsync();
    }

    private async Task HandleBackdropClick()
    {
        await HandleClose();
    }

    private async Task ExecuteInput()
    {
        if (isExecuting) return;

        isExecuting = true;
        StateHasChanged();

        try
        {
            await ExecuteInputRequested.InvokeAsync();

            // Refresh the payload data after execution
            IncomingPayloadJson = BackingNode?.Input;
            OutputPayloadJson = BackingNode?.Result;

            // Reset error dismissed state after execution if there's an error
            if (BackingNode?.HasError == true)
            {
                _errorDismissed = false;
                _lastErrorMessage = BackingNode.ErrorMessage;
            }
            else if (BackingNode?.HasError == false)
            {
                // Clear tracking when there's no error
                _lastErrorMessage = null;
            }

            StateHasChanged();

            await Task.Delay(1000);
        }
        catch (Exception ex)
        {
        }
        finally
        {
            isExecuting = false;
            StateHasChanged();
        }
    }

    private void TriggerAutoSave()
    {
        // Cancel previous timer if exists
        _autoSaveTimer?.Dispose();

        // Start new timer that will save after the debounce delay
        _autoSaveTimer = new System.Threading.Timer(async _ =>
        {
            await InvokeAsync(async () => await SaveMappings());
        }, null, _autoSaveDelayMs, System.Threading.Timeout.Infinite);
    }

    private async Task SaveMappings()
    {
        if (isSaving) return;

        isSaving = true;
        StateHasChanged();

        try
        {
            BackingNode.MethodOutputToNodeOutputMap = ViewModel.MethodOutputToNodeOutputMap
                .ToList();
            BackingNode.NodeInputToMethodInputMap = ViewModel.NodeInputToMethodInputMap
                .ToList();

            BackingNode.DictionaryParameterMappings = ViewModel.DictionaryParameterMappings
                .ToDictionary(
                    kvp => kvp.Key,
                    kvp => kvp.Value.ToList()
                );

            await SaveRequested.InvokeAsync();

            saveSuccess = true;
            StateHasChanged();

            // Reset success animation after a delay
            await Task.Delay(300);
            saveSuccess = false;
        }
        catch (Exception ex)
        {
        }
        finally
        {
            isSaving = false;
            StateHasChanged();
        }
    }

    private void RemoveMethodOutputToNodeOutputMap(PathMapEntry viewModel)
    {
        ViewModel.MethodOutputToNodeOutputMap.Remove(viewModel);
        StateHasChanged();
    }

    private void RemoveNodeInputToMethodInputMap(PathMapEntry viewModel)
    {
        ViewModel.NodeInputToMethodInputMap.Remove(viewModel);
        StateHasChanged();
    }

    private void AddInputMapping()
    {
        var parameters = BackingNode?.BackingMethod?.GetParameters() ?? Array.Empty<ParameterInfo>();
        var mappedParams = new HashSet<string>(ViewModel.NodeInputToMethodInputMap.Select(m => m.To));

        // Find the first unmapped parameter (excluding attributed dictionaries as they have their own section)
        var unmappedParam = parameters.FirstOrDefault(p =>
            !TypeHelpers.IsAutoInjectedParameter(p) &&
            !(p.ParameterType == typeof(Dictionary<string, string>) && TypeHelpers.HasDictionaryMappingAttribute(p)) &&
            !mappedParams.Contains(p.Name ?? string.Empty));

        if (unmappedParam != null)
        {
            // Add mapping with smart default
            var hasInputFieldAttr = unmappedParam.GetCustomAttribute<BlazorExecutionFlow.Flow.Attributes.BlazorFlowInputFieldAttribute>() != null;
            var defaultValue = hasInputFieldAttr
                ? GeneratePlaceholderLiteral(unmappedParam.ParameterType, unmappedParam.Name)
                : $"{{{{input.{unmappedParam.Name}}}}}";

            ViewModel.NodeInputToMethodInputMap.Add(new PathMapEntry
            {
                From = defaultValue,
                To = unmappedParam.Name ?? string.Empty
            });
            StateHasChanged();
        }
        // Don't add empty mapping if all parameters are already mapped
    }

    private void AddOutputMapping()
    {
        var returnProps = GetReturnProperties();
        if (returnProps != null && returnProps.Any())
        {
            var mappedProps = new HashSet<string>(ViewModel.MethodOutputToNodeOutputMap.Select(m => m.From));

            // Find the first unmapped property
            var unmappedProp = returnProps.FirstOrDefault(p =>
                p.Name != null &&
                !mappedProps.Contains(p.Name));

            if (unmappedProp.Name != null)
            {
                // Add mapping with property name as both source and target
                ViewModel.MethodOutputToNodeOutputMap.Add(new PathMapEntry
                {
                    From = unmappedProp.Name,
                    To = unmappedProp.Name
                });
                StateHasChanged();
            }
            // Don't add empty mapping if all properties are already mapped
        }
        else
        {
            // For non-object return types (e.g., int, string), check if "result" is already mapped
            var mappedProps = new HashSet<string>(ViewModel.MethodOutputToNodeOutputMap.Select(m => m.From));
            if (!mappedProps.Contains("result"))
            {
                ViewModel.MethodOutputToNodeOutputMap.Add(new PathMapEntry
                {
                    From = "result",
                    To = "result"
                });
                StateHasChanged();
            }
            // Don't add empty mapping if "result" is already mapped
        }
    }

    private bool CanAddInputMapping()
    {
        var parameters = BackingNode?.BackingMethod?.GetParameters() ?? Array.Empty<ParameterInfo>();
        var availableParams = parameters
            .Where(p => !TypeHelpers.IsAutoInjectedParameter(p) &&
                        !(p.ParameterType == typeof(Dictionary<string, string>) && TypeHelpers.HasDictionaryMappingAttribute(p)))
            .ToList();
        var mappedParams = new HashSet<string>(ViewModel.NodeInputToMethodInputMap.Select(m => m.To).Where(t => !string.IsNullOrEmpty(t)));

        // Can add if there are unmapped parameters
        return availableParams.Any(p => !mappedParams.Contains(p.Name ?? string.Empty));
    }

    private ParameterInfo? GetParameterInfo(string parameterName)
    {
        if (string.IsNullOrEmpty(parameterName)) return null;
        var parameters = BackingNode?.BackingMethod?.GetParameters() ?? Array.Empty<ParameterInfo>();
        return parameters.FirstOrDefault(p => p.Name == parameterName);
    }

    /// <summary>
    /// Formats a type name to display properly, handling generics like List<int> instead of List`1
    /// </summary>
    private string FormatTypeName(Type? type) => TypeHelpers.FormatTypeName(type);

    private IEnumerable<ParameterInfo> GetAvailableInputParameters(PathMapEntry currentMapping)
    {
        var parameters = BackingNode?.BackingMethod?.GetParameters() ?? Array.Empty<ParameterInfo>();
        var availableParams = parameters
            .Where(p => !TypeHelpers.IsAutoInjectedParameter(p) &&
                        !(p.ParameterType == typeof(Dictionary<string, string>) && TypeHelpers.HasDictionaryMappingAttribute(p)))
            .ToList();

        // Get all mapped parameter names except the current one
        var mappedParams = new HashSet<string>(
            ViewModel.NodeInputToMethodInputMap
                .Where(m => m != currentMapping && !string.IsNullOrEmpty(m.To))
                .Select(m => m.To)
        );

        // Return parameters that are either not mapped or are the current mapping's target
        return availableParams.Where(p =>
            !mappedParams.Contains(p.Name ?? string.Empty) ||
            p.Name == currentMapping.To
        );
    }

    private bool CanAddOutputMapping()
    {
        var returnProps = GetReturnProperties();

        if (returnProps != null && returnProps.Any())
        {
            var mappedProps = new HashSet<string>(ViewModel.MethodOutputToNodeOutputMap.Select(m => m.From).Where(f => !string.IsNullOrEmpty(f)));
            // Can add if there are unmapped properties
            return returnProps.Any(p => p.Name != null && !mappedProps.Contains(p.Name));
        }
        else
        {
            // For non-object return types, can add if "result" is not mapped
            var mappedProps = new HashSet<string>(ViewModel.MethodOutputToNodeOutputMap.Select(m => m.From).Where(f => !string.IsNullOrEmpty(f)));
            return !mappedProps.Contains("result");
        }
    }

    private IEnumerable<(string? Type, string? Name)> GetAvailableOutputProperties(PathMapEntry currentMapping, List<(string? Type, string? Name)> allProps)
    {
        // Get all mapped property names except the current one
        var mappedProps = new HashSet<string>(
            ViewModel.MethodOutputToNodeOutputMap
                .Where(m => m != currentMapping && !string.IsNullOrEmpty(m.From))
                .Select(m => m.From)
        );

        // Return properties that are either not mapped or are the current mapping's source
        return allProps.Where(p =>
            p.Name != null && (
                !mappedProps.Contains(p.Name) ||
                p.Name == currentMapping.From
            )
        );
    }

    private bool IsOutputValueAvailable(PathMapEntry currentMapping, string value)
    {
        // Get all mapped values except the current one
        var mappedValues = new HashSet<string>(
            ViewModel.MethodOutputToNodeOutputMap
                .Where(m => m != currentMapping && !string.IsNullOrEmpty(m.From))
                .Select(m => m.From)
        );

        // Value is available if not mapped or is the current mapping's source
        return !mappedValues.Contains(value) || value == currentMapping.From;
    }

    public class NodeEditorModalViewModel
    {
        public List<PathMapEntry> NodeInputToMethodInputMap { get; set; } = new();
        public List<PathMapEntry> MethodOutputToNodeOutputMap { get; set; } = new();
        public Dictionary<string, List<PathMapEntry>> DictionaryParameterMappings { get; set; } = new();
    }

    private string GetOutputPreviewValue(string propertyPath)
    {
        if (string.IsNullOrWhiteSpace(propertyPath) || OutputPayloadJson == null)
            return "N/A";

        try
        {
            // For output, we're showing what value exists at the "From" property
            // This would come from the Result object after execution
            var outputSection = OutputPayloadJson["output"];
            if (outputSection == null)
                return "N/A";

            // Try to get the value at the property path
            var value = outputSection.AsObject()?.GetByPath(propertyPath);
            if (value != null)
            {
                return JsonSerializer.Serialize(value, new JsonSerializerOptions { WriteIndented = false });
            }

            return "N/A";
        }
        catch (Exception ex)
        {
            return $"Error: {ex.Message}";
        }
    }

    // Drag and Drop handlers
    private void HandleDragStart(DragEventArgs e, string fieldPath)
    {
        _draggedFieldPath = fieldPath;
    }

    private void HandleDragOver(DragEventArgs e)
    {
        // Allow drop by preventing default
    }

    private void HandleDrop(DragEventArgs e, PathMapEntry mapping)
    {
        if (!string.IsNullOrEmpty(_draggedFieldPath))
        {
            // Wrap the path in Scriban template syntax
            mapping.From = $"{{{{{_draggedFieldPath}}}}}";
            _draggedFieldPath = null;
            TriggerAutoSave();
            StateHasChanged();
        }
    }

    // Preview methods
    private void TogglePreview(PathMapEntry mapping, MouseEventArgs e)
    {
        // If clicking the same mapping, just close it
        if (_previewMapping == mapping)
        {
            _previewMapping = null;
            return;
        }

        // Check if we have valid data to preview
        if (string.IsNullOrWhiteSpace(mapping.From) || IncomingPayloadJson is null)
        {
            // Don't show preview if there's no template or no incoming payload
            _previewMapping = null;
            return;
        }

        // Set the new preview mapping - this will show the popover
        _previewMapping = mapping;
    }

    private async Task PositionPopoverByElement()
    {
        if (_previewPopoverRef.Id == null)
        {
            return;
        }

        try
        {
            // Use JavaScript to find the button and position relative to it
            var previewId = _previewMapping?.GetHashCode() ?? 0;
            await JSRuntime.InvokeVoidAsync("positionPopoverById", previewId);
        }
        catch (JSException jsEx)
        {
        }
        catch (Exception ex)
        {
        }
    }

    private async Task PositionPopover()
    {
        try
        {
            // Verify the popover element exists before trying to position it
            await JSRuntime.InvokeVoidAsync("positionPopover", _previewButtonRef, _previewPopoverRef);
        }
        catch (JSException jsEx)
        {
        }
        catch (Exception ex)
        {
        }
    }

    private async Task SetupClickAwayListener()
    {
        try
        {
            var dotNetRef = DotNetObjectReference.Create(this);
            await JSRuntime.InvokeVoidAsync("setupPopoverClickAway", dotNetRef, _previewPopoverRef, _previewButtonRef);
        }
        catch (Exception)
        {
            // Ignore errors if JS isn't loaded yet
        }
    }

    private async Task RemoveClickAwayListener()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("removePopoverClickAway");
        }
        catch (Exception)
        {
            // Ignore errors if JS isn't loaded yet
        }
    }

    [JSInvokable]
    public void ClosePopover()
    {
        _previewMapping = null;
        StateHasChanged();
    }

    private void DismissError()
    {
        _errorDismissed = true;
        StateHasChanged();
    }

    private string GetScribanPreviewValue(PathMapEntry pathMapEntry)
    {
        var templateString = pathMapEntry.From;
        var expectedType = BackingNode?.BackingMethod?.GetParameters()
            .FirstOrDefault(p => p.Name == pathMapEntry.To)?.ParameterType ?? typeof(string);

        if (string.IsNullOrWhiteSpace(templateString) || IncomingPayloadJson is null)
            return "...";

        try
        {
            var obj = ScribanHelpers.GetScribanObject(templateString, (JsonObject)IncomingPayloadJson.DeepClone(), null, expectedType);
            var result = obj?.ToString();
            return string.IsNullOrEmpty(result) ? "null" : result;
        }
        catch (Exception ex)
        {
            return $"Error: {ex.Message}";
        }
    }

    // ==========================================
    // JSON FILTER SYSTEM
    // ==========================================

    /// <summary>
    /// Delegate for JSON filters. Returns true if the node should be included, false to exclude it.
    /// </summary>
    private delegate bool JsonFilter(JsonNode? node, string key, int depth);

    /// <summary>
    /// Gets the filtered JSON based on current filter settings.
    /// </summary>
    private JsonNode? GetFilteredJson()
    {
        if (IncomingPayloadJson == null)
            return null;

        // Build filter chain based on active settings
        var filters = new List<JsonFilter>();

        // Add search filter if there's a search term
        if (!string.IsNullOrWhiteSpace(_jsonSearchTerm) && _filterRegistry.ContainsKey("search"))
            filters.Add(_filterRegistry["search"]);

        // Add mode-specific data filters (not display modes like "compact" or "keys")
        // Display modes (compact, keys) are handled in RenderDraggableJson
        if (_filterRegistry.ContainsKey(_jsonFilterMode))
            filters.Add(_filterRegistry[_jsonFilterMode]);

        // If no filters are active, return original JSON
        if (filters.Count == 0)
            return IncomingPayloadJson;

        // Apply all registered filters
        var filtered = ApplyFilters(IncomingPayloadJson.DeepClone(), filters);
        return filtered;
    }

    /// <summary>
    /// Applies a chain of filters to a JsonNode recursively.
    /// </summary>
    private JsonNode? ApplyFilters(JsonNode? node, List<JsonFilter> filters, string key = "", int depth = 0, bool includeAllChildren = false)
    {
        if (node == null)
            return null;

        // If we're inside a matched subtree, include everything without filtering
        if (includeAllChildren)
            return node.DeepClone();

        if (node is JsonObject obj)
        {
            var filtered = new JsonObject();

            foreach (var kvp in obj.AsEnumerable())
            {
                // Check if this key matches search (for search filter specifically)
                bool keyMatchesSearch = !string.IsNullOrWhiteSpace(_jsonSearchTerm) &&
                                       kvp.Key.Contains(_jsonSearchTerm, StringComparison.OrdinalIgnoreCase);

                // Apply all filters - if any filter returns false, skip this node
                bool shouldInclude = filters.All(filter => filter(kvp.Value, kvp.Key, depth));

                if (!shouldInclude)
                    continue;

                // If key matches search, include entire subtree without filtering
                var filteredValue = ApplyFilters(kvp.Value, filters, kvp.Key, depth + 1, keyMatchesSearch);
                if (filteredValue != null)
                {
                    filtered.Add(kvp.Key, filteredValue);
                }
            }

            return filtered.Count > 0 ? filtered : null;
        }
        else if (node is JsonArray arr)
        {
            // Check if arrays should be filtered out entirely
            bool shouldInclude = filters.All(filter => filter(node, key, depth));
            if (!shouldInclude)
                return null;

            var filtered = new JsonArray();

            foreach (var item in arr)
            {
                // Recursively filter nested nodes
                var filteredItem = ApplyFilters(item, filters, key, depth + 1, false);
                if (filteredItem != null)
                {
                    filtered.Add(filteredItem);
                }
            }

            return filtered.Count > 0 ? filtered : null;
        }
        else if (node is JsonValue)
        {
            // Apply all filters - if any filter returns false, exclude this value
            bool shouldInclude = filters.All(filter => filter(node, key, depth));
            return shouldInclude ? node.DeepClone() : null;
        }

        return node.DeepClone();
    }

    /// <summary>
    /// Gets the available filters for the dropdown, excluding "search" which is applied separately.
    /// </summary>
    private Dictionary<string, string> GetAvailableFilters()
    {
        var filters = new Dictionary<string, string>();

        foreach (var filterKey in _filterRegistry.Keys)
        {
            // Exclude "search" - it's applied separately when there's a search term
            if (filterKey == "search")
                continue;

            // Format display name: capitalize first letter and add "only" suffix
            var displayName =  filterKey;
            filters.Add(filterKey, displayName);
        }

        return filters;
    }

    // ==========================================
    // REGISTERED FILTERS
    // ==========================================
    // To add a new DATA filter:
    // 1. Create a method with signature: bool MyFilter(JsonNode? node, string key, int depth)
    // 2. Return true to include the node, false to exclude it
    // 3. Register it in OnInitialized() using: _filterRegistry.Add("filtername", MyFilter);

    /// <summary>
    /// Filter: Search - shows only nodes matching search term and their parent paths.
    /// </summary>
    private bool SearchFilter(JsonNode? node, string key, int depth)
    {
        if (string.IsNullOrWhiteSpace(_jsonSearchTerm))
            return true;

        // Check if key matches
        if (key.Contains(_jsonSearchTerm, StringComparison.OrdinalIgnoreCase))
            return true;

        // Check if value matches (for primitives)
        if (node is JsonValue val)
        {
            var jsonString = val.ToJsonString();
            return jsonString.Contains(_jsonSearchTerm, StringComparison.OrdinalIgnoreCase);
        }

        // For objects and arrays, check if they contain matching nested values
        // If they do, include them (they are parent paths to matches)
        return JsonNodeContainsSearchTerm(node, _jsonSearchTerm);
    }

    /// <summary>
    /// Filter: Primitives only - excludes nested objects and arrays.
    /// </summary>
    private bool EnvironmentOnlyFilter(JsonNode? node, string key, int depth)
    {
        if (depth == 0)
        {
            // At depth 1, allow only specific global keys
            var allowedKeys = new HashSet<string> { "environment" };
            return allowedKeys.Contains(key.ToLowerInvariant());
        }
        else
        {
            return true;
        }
    }

    private bool GlobalOnlyFilter(JsonNode? node, string key, int depth)
    {
        if (depth == 0)
        {
            // At depth 1, allow only specific global keys
            var allowedKeys = new HashSet<string> { "workflow" };
            return allowedKeys.Contains(key.ToLowerInvariant());
        }
        else
        {
            return true;
        }
    }

    private bool InputOnlyFilter(JsonNode? node, string key, int depth)
    {
        if (depth == 0)
        {
            // At depth 1, allow only specific global keys
            var allowedKeys = new HashSet<string> { "input" };
            return allowedKeys.Contains(key.ToLowerInvariant());
        }
        else
        {
            return true;
        }
    }

    private bool NodeOnlyFilter(JsonNode? node, string key, int depth)
    {
        if (depth == 0)
        {
            // At depth 1, allow only specific global keys
            var allowedKeys = new HashSet<string> { "nodes" };
            return allowedKeys.Contains(key.ToLowerInvariant());
        }
        else
        {
            return true;
        }
    }

    /// <summary>
    /// Renders draggable JSON. Assumes the node is already filtered.
    /// Only handles display modes (compact, keys).
    /// </summary>
    private RenderFragment RenderDraggableJson(JsonNode? node, string path, int depth = 0)
    {
        return builder =>
        {
            if (node == null)
            {
                if (string.IsNullOrEmpty(path))
                {
                    builder.AddContent(0, "Execute the previous node to see the input");
                }
                else
                {
                    builder.AddContent(0, "null");
                }

                return;
            }

            // Display modes only (filtering already done)
            bool isCompact = _jsonFilterMode == "compact";
            bool showKeysOnly = _jsonFilterMode == "keys";
            var indent = isCompact ? "" : new string(' ', depth * 2);
            var newline = isCompact ? "" : "\n";

            if (node is JsonObject obj)
            {
                builder.AddContent(0, "{" + newline);
                var properties = obj.AsEnumerable().ToList();

                for (int i = 0; i < properties.Count; i++)
                {
                    string propPath;
                    var kvp = properties[i];

                    if (kvp.Key.Contains("-"))
                    {
                        propPath = string.IsNullOrEmpty(path) ? kvp.Key : $"{path}[\"{kvp.Key}\"]";
                    }
                    else
                    {
                        propPath = string.IsNullOrEmpty(path) ? kvp.Key : $"{path}.{kvp.Key}";
                    }

                    if (!isCompact)
                    {
                        builder.AddContent(1, indent + "  ");
                    }

                    // Determine if this key matches the search term for highlighting
                    bool keyMatches = !string.IsNullOrWhiteSpace(_jsonSearchTerm) &&
                                      kvp.Key.Contains(_jsonSearchTerm, StringComparison.OrdinalIgnoreCase);

                    // Render key as draggable
                    builder.OpenElement(2, "span");
                    builder.AddAttribute(3, "class", keyMatches ? "json-key draggable json-highlight" : "json-key draggable");
                    builder.AddAttribute(4, "draggable", "true");
                    builder.AddAttribute(5, "ondragstart", EventCallback.Factory.Create<DragEventArgs>(this, e => HandleDragStart(e, $"{propPath} | object.to_json")));
                    builder.AddContent(6, $"\"{kvp.Key}\"");
                    builder.CloseElement();

                    if (!showKeysOnly)
                    {
                        builder.AddContent(7, isCompact ? ":" : ": ");
                        builder.AddContent(8, RenderDraggableJson(kvp.Value, propPath, depth + 1));
                    }

                    if (i < properties.Count - 1)
                    {
                        builder.AddContent(9, isCompact ? "," : ",");
                    }
                    builder.AddContent(10, newline);
                }
                builder.AddContent(11, (isCompact ? "" : indent) + "}");
            }
            else if (node is JsonArray arr)
            {
                builder.AddContent(0, "[" + newline);
                for (int i = 0; i < arr.Count; i++)
                {
                    var itemPath = $"{path}[{i}]";
                    if (!isCompact)
                    {
                        builder.AddContent(1, indent + "  ");
                    }
                    builder.AddContent(2, RenderDraggableJson(arr[i], $"{itemPath} | object.to_json", depth + 1));

                    if (i < arr.Count - 1)
                    {
                        builder.AddContent(3, isCompact ? "," : ",");
                    }
                    builder.AddContent(4, newline);
                }
                builder.AddContent(5, (isCompact ? "" : indent) + "]");
            }
            else if (node is JsonValue val)
            {
                // Render primitive value as draggable
                var jsonString = val.ToJsonString();

                // Check if value matches search term for highlighting
                bool valueMatches = !string.IsNullOrWhiteSpace(_jsonSearchTerm) &&
                                   jsonString.Contains(_jsonSearchTerm, StringComparison.OrdinalIgnoreCase);

                builder.OpenElement(0, "span");
                builder.AddAttribute(1, "class", valueMatches ? "json-value draggable json-highlight" : "json-value draggable");
                builder.AddAttribute(2, "draggable", "true");
                builder.AddAttribute(3, "ondragstart", EventCallback.Factory.Create<DragEventArgs>(this, e => HandleDragStart(e, path)));
                builder.AddContent(4, jsonString);
                builder.CloseElement();
            }
        };
    }

    // Helper to check if a JsonNode contains the search term
    private bool JsonNodeContainsSearchTerm(JsonNode? node, string searchTerm)
    {
        if (node == null || string.IsNullOrWhiteSpace(searchTerm))
            return false;

        if (node is JsonObject obj)
        {
            return obj.AsEnumerable().Any(kvp =>
                kvp.Key.Contains(searchTerm, StringComparison.OrdinalIgnoreCase) ||
                JsonNodeContainsSearchTerm(kvp.Value, searchTerm)
            );
        }
        else if (node is JsonArray arr)
        {
            return arr.Any(item => JsonNodeContainsSearchTerm(item, searchTerm));
        }
        else if (node is JsonValue val)
        {
            return val.ToJsonString().Contains(searchTerm, StringComparison.OrdinalIgnoreCase);
        }

        return false;
    }

    // Dictionary parameter methods
    private IEnumerable<ParameterInfo> GetDictionaryParameters()
    {
        var parameters = BackingNode?.BackingMethod?.GetParameters() ?? Array.Empty<ParameterInfo>();
        return parameters.Where(p => p.ParameterType == typeof(Dictionary<string, string>) && TypeHelpers.HasDictionaryMappingAttribute(p));
    }

    private void AddDictionaryEntry(string parameterName)
    {
        if (!ViewModel.DictionaryParameterMappings.ContainsKey(parameterName))
        {
            ViewModel.DictionaryParameterMappings[parameterName] = new List<PathMapEntry>();
        }

        ViewModel.DictionaryParameterMappings[parameterName].Add(new PathMapEntry
        {
            From = "",  // Value (payload path or template)
            To = ""     // Dictionary key
        });

        TriggerAutoSave();
        StateHasChanged();
    }

    private void RemoveDictionaryEntry(string parameterName, PathMapEntry entry)
    {
        if (ViewModel.DictionaryParameterMappings.TryGetValue(parameterName, out var entries))
        {
            entries.Remove(entry);
            TriggerAutoSave();
            StateHasChanged();
        }
    }

    // Node name editing methods
    private void StartEditingNodeName()
    {
        _editingNodeName = BackingNode?.NameOverride ?? BackingNode?.Name ?? "";
        _isEditingNodeName = true;
        StateHasChanged();

        // Focus the input after render
        _ = Task.Run(async () =>
        {
            await Task.Delay(50);
            await JSRuntime.InvokeVoidAsync("eval", $"document.querySelector('.node-name-input')?.focus()");
        });
    }

    private void SaveNodeName()
    {
        if (BackingNode != null)
        {
            if (!string.IsNullOrWhiteSpace(_editingNodeName))
            {
                // Only set NameOverride if it's different from the backing name
                if (_editingNodeName.Trim() != BackingNode.BackingMethod.Name)
                {
                    BackingNode.NameOverride = _editingNodeName.Trim();
                }
                else
                {
                    BackingNode.NameOverride = null;
                }
            }
            // If empty, keep the existing override (don't clear it)

            // Trigger auto-save to persist the name change immediately
            TriggerAutoSave();
        }
        _isEditingNodeName = false;
        StateHasChanged();
    }

    private void HandleNodeNameKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
        {
            SaveNodeName();
        }
        else if (e.Key == "Escape")
        {
            _isEditingNodeName = false;
            StateHasChanged();
        }
    }

    /// <summary>
    /// Renders selectable JSON (non-draggable, for output display).
    /// </summary>
    private RenderFragment RenderSelectableJson(JsonNode? node, string path, int depth = 0)
    {
        return builder =>
        {
            if (node == null)
            {
                builder.AddContent(0, "Execute the node to see the output");
                return;
            }

            var indent = new string(' ', depth * 2);
            const string newline = "\n";

            if (node is JsonObject obj)
            {
                builder.AddContent(0, "{" + newline);
                var properties = obj.AsEnumerable().ToList();

                for (int i = 0; i < properties.Count; i++)
                {
                    var kvp = properties[i];
                    builder.AddContent(1, indent + "  ");

                    // Render key (styled but not draggable)
                    builder.OpenElement(2, "span");
                    builder.AddAttribute(3, "class", "json-key");
                    builder.AddAttribute(4, "style", "color: #93c5fd; font-weight: 600;");
                    builder.AddContent(5, $"\"{kvp.Key}\"");
                    builder.CloseElement();

                    builder.AddContent(6, ": ");

                    string propPath;
                    if (kvp.Key.Contains("-"))
                    {
                        propPath = string.IsNullOrEmpty(path) ? kvp.Key : $"{path}[\"{kvp.Key}\"]";
                    }
                    else
                    {
                        propPath = string.IsNullOrEmpty(path) ? kvp.Key : $"{path}.{kvp.Key}";
                    }

                    builder.AddContent(7, RenderSelectableJson(kvp.Value, propPath, depth + 1));

                    if (i < properties.Count - 1)
                    {
                        builder.AddContent(8, ",");
                    }
                    builder.AddContent(9, newline);
                }
                builder.AddContent(10, indent + "}");
            }
            else if (node is JsonArray arr)
            {
                builder.AddContent(0, "[" + newline);
                for (int i = 0; i < arr.Count; i++)
                {
                    var itemPath = $"{path}[{i}]";
                    builder.AddContent(1, indent + "  ");
                    builder.AddContent(2, RenderSelectableJson(arr[i], itemPath, depth + 1));

                    if (i < arr.Count - 1)
                    {
                        builder.AddContent(3, ",");
                    }
                    builder.AddContent(4, newline);
                }
                builder.AddContent(5, indent + "]");
            }
            else if (node is JsonValue val)
            {
                // Render value (styled)
                builder.OpenElement(0, "span");
                builder.AddAttribute(1, "class", "json-value");
                builder.AddAttribute(2, "style", "color: #a78bfa;");

                var jsonString = val.ToJsonString();
                builder.AddContent(3, jsonString);
                builder.CloseElement();
            }
        };
    }

    public void Dispose()
    {
        _autoSaveTimer?.Dispose();
    }
}
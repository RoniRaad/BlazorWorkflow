@using System.Reflection
@using BlazorExecutionFlow.Helpers
@using BlazorExecutionFlow.Models.NodeV2
@using Microsoft.AspNetCore.Components.Forms
@using System.Text.Json
@using System.Text.Json.Nodes
@using System.Net.Http
@using System.Net.Http.Json
@using Microsoft.AspNetCore.Components.Routing
@using Microsoft.AspNetCore.Components.Web
@using static Microsoft.AspNetCore.Components.Web.RenderMode
@using Microsoft.AspNetCore.Components.Web.Virtualization
@using Scriban
@using Scriban.Runtime

<!-- Modal Backdrop -->
<div class="modal-backdrop fade show" @onclick="HandleBackdropClick"></div>

<!-- Node editor modal -->
<div style="display:block;" class="modal fade show node-editor-modal"
id="nodeEditorModal"
tabindex="-1"
aria-labelledby="nodeEditorLabel"
aria-modal="true"
role="dialog"
@onkeydown="HandleKeyDown">
    <div class="modal-dialog node-editor-dialog">
        <div class="modal-content node-editor-content">
            <div class="modal-header node-editor-header">
                <div>
                    <h5 class="modal-title" id="nodeEditorLabel">Edit node: @(BackingNode?.BackingMethod?.Name ?? "Unknown")</h5>
                    <p class="node-editor-subtitle">Payload based mapping</p>
                </div>
                <button type="button"
                class="btn btn-xs btn-outline-secondary"
                @onclick="ExecuteInput"
                disabled="@isExecuting"
                data-role="execute-input"
                style="padding-top: 1px;padding-bottom: 1.5px;position: absolute;right: 42px;">
                    @if (isExecuting)
                    {
                        <span class="spinner-border spinner-border-sm me-1" role="status" aria-hidden="true"></span>
                    }
                    Execute Flow
                </button>
                <button type="button"
                style="color:white"
                class="btn-close"
                @onclick="HandleClose"
                aria-label="Close modal">
                </button>
            </div>

            <!-- Error Alert -->
            @if (BackingNode?.HasError == true)
            {
                <div class="alert alert-danger node-error-alert" role="alert">
                    <div class="error-header">
                        <svg class="error-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="12" cy="12" r="10"></circle>
                            <line x1="12" y1="8" x2="12" y2="12"></line>
                            <line x1="12" y1="16" x2="12.01" y2="16"></line>
                        </svg>
                        <strong>Execution Error</strong>
                    </div>
                    <p class="error-message">@BackingNode.ErrorMessage</p>
                    @if (BackingNode.LastException != null)
                    {
                        <details class="error-details">
                            <summary>View stack trace</summary>
                            <pre class="error-stack">@BackingNode.LastException.StackTrace</pre>
                        </details>
                    }
                </div>
            }

            <div class="modal-body node-editor-body">
                <div class="node-editor-grid">
                    <!-- INPUT PANEL -->
                    <section class="node-editor-panel node-editor-panel-input">
                        <header class="panel-header">
                            <span class="pill pill-input">Input</span>

                            <h6>Incoming payload</h6>
                            <p class="panel-caption">Preview the payload that arrives at this node.</p>
                        </header>
                        <div class="panel-body">
                            <div class="payload-preview" data-role="payload-preview">
                                @{
                                    var inputString = JsonSerializer.Serialize(IncomingPayloadJson, new JsonSerializerOptions() { Encoder = System.Text.Encodings.Web.JavaScriptEncoder.UnsafeRelaxedJsonEscaping, WriteIndented = true });
                                    if (inputString == "null")
                                    {
                                        inputString = "...";
                                    }
                                }
                                @(inputString)
                            </div>

                            <div class="panel-section">
                                <div class="panel-section-header">
                                    <span>Fields</span>
                     
                                </div>
                                <div class="payload-field-list" data-role="payload-field-list">
                                    <!-- Example chip, clone these in JS -->
                                    @foreach (var fieldKvp in IncomingPayloadJson?.AsObject()?["input"]?.AsObject() ?? [])
                                    {
                                        var fieldPath = $"input.{fieldKvp.Key}";
                                        <button type="button"
                                                class="payload-field-chip"
                                                draggable="true"
                                                @ondragstart="@((e) => HandleDragStart(e, fieldPath))"
                                                data-role="payload-field"
                                                data-path="@fieldKvp.Key">
                                            @fieldPath
                                        </button>
                                    }

                                </div>
                            </div>

                            <hr class="panel-divider mt-3" />

                            <!-- Scriban Preview Section -->
                            <div class="panel-section">
                                <div class="panel-section-header">
                                    <span>Scriban Preview</span>
                                </div>
                                <div class="scriban-preview-list">
                                    @if (ViewModel.NodeInputToMethodInputMap.Any())
                                    {
                                        @foreach (var mapping in ViewModel.NodeInputToMethodInputMap.Where(m => !string.IsNullOrWhiteSpace(m.From) && !string.IsNullOrWhiteSpace(m.To)))
                                        {
                                            var previewValue = GetScribanPreviewValue(mapping.From);
                                            <div class="scriban-preview-item">
                                                <div class="scriban-preview-label">@mapping.To</div>
                                                <div class="scriban-preview-value">@previewValue</div>
                                            </div>
                                        }
                                    }
                                    else
                                    {
                                        <p class="text-muted small">No input mappings configured</p>
                                    }
                                </div>
                            </div>
                        </div>
                    </section>

                    <!-- PROCESSING PANEL -->
                    <section class="node-editor-panel node-editor-panel-processing">
                        <header class="panel-header">
                            <span class="pill pill-processing">Processing</span>
                            <h6>Function mapping</h6>
                            <p class="panel-caption">Map payload fields into your function and back out again.</p>
                        </header>

                        <div class="panel-body panel-body-scroll">
                            <!-- Function input map -->
                            <div class="panel-section" data-role="function-input-map">
                                <div class="panel-section-header">
                                    <span>Function input map</span>
                                    <button onclick="@AddInputMapping" type="button"
                                            class="btn btn-xs btn-outline-secondary"
                                            disabled="@(!CanAddInputMapping())"
                                            data-role="add-input-mapping">
                                        Add mapping
                                    </button>
                                </div>

                                <div class="mapping-list" data-role="input-mapping-list">
                                    <!-- Template row; duplicate dynamically -->
                                    @foreach (var inputMapping in ViewModel.NodeInputToMethodInputMap)
                                    {
                                        <div class="mapping-row" data-role="input-mapping-row">
                                            <div class="mapping-col">
                                                <label>Payload path</label>
                                                <input @bind="inputMapping.From"
                                                       @bind:event="oninput"
                                                       type="text"
                                                       class="form-control form-control-sm droppable-input"
                                                       placeholder="e.g. input.name or {{input.name}}"
                                                       aria-label="Payload path for input mapping"
                                                       @ondragover="@((e) => HandleDragOver(e))"
                                                       @ondragover:preventDefault="true"
                                                       @ondrop="@((e) => HandleDrop(e, inputMapping))"
                                                       required
                                                       data-role="payload-path" />
                                            </div>
                                            <div class="mapping-arrow">→</div>
                                            <div class="mapping-col">
                                                <label>Parameter</label>
                                                <InputSelect @bind-Value="inputMapping.To"
                                                             class="form-select form-select-sm"
                                                             aria-label="Target parameter for input mapping"
                                                             data-role="parameter-name">
                                                    <option value="">Select parameter…</option>
                                                    @foreach (var param in GetAvailableInputParameters(inputMapping))
                                                    {
                                                        <option @key="@param.Name" value="@param.Name">(@param.ParameterType.Name) @param.Name</option>
                                                    }
                                                </InputSelect>
                                            </div>
                                            <button onclick="@(() => RemoveNodeInputToMethodInputMap(inputMapping))"
                                                    type="button"
                                                    class="btn btn-icon btn-xs"
                                                    aria-label="Remove input mapping"
                                                    title="Remove this input mapping"
                                                    data-role="remove-mapping">
                                                <span aria-hidden="true">✕</span>
                                            </button>
                                        </div>
                                    }
                                </div>
                            </div>

                            <hr class="panel-divider" />

                            <!-- Function output map -->
                            @if (BackingNode.DeclaredOutputPorts.Count == 0)
                            {
                                <div class="panel-section" data-role="function-output-map">
                                    <div class="panel-section-header">
                                        <span>Function output map</span>
                                        <button onclick="@AddOutputMapping" type="button"
                                                class="btn btn-xs btn-outline-secondary"
                                                disabled="@(!CanAddOutputMapping())"
                                                data-role="add-output-mapping">
                                            Add mapping
                                        </button>
                                    </div>

                                    <div class="mapping-list" data-role="output-mapping-list">
                                        @{ var propInfos = GetReturnProperties(); }
                                        @if (propInfos is not null)
                                        {
                                            @foreach (var outputMapping in ViewModel.MethodOutputToNodeOutputMap)
                                            {
                                                <div class="mapping-row" data-role="output-mapping-row">
                                                    <div class="mapping-col">
                                                        <label>Function output</label>
                                                        <InputSelect @bind-Value="outputMapping.From"
                                                                     class="form-select form-select-sm"
                                                                     aria-label="Function output field"
                                                                     data-role="function-output">
                                                            <option value="">Select output…</option>

                                                            @if (propInfos.Count() > 0)
                                                            {
                                                                @foreach (var property in GetAvailableOutputProperties(outputMapping, propInfos))
                                                                {
                                                                    <option value="@property.Name">(@property.Type) @property.Name</option>
                                                                }
                                                            }
                                                            else
                                                            {
                                                                @if (IsOutputValueAvailable(outputMapping, "result"))
                                                                {
                                                                    <option value="result">(@BackingNode.BackingMethod.ReturnType.Name) result</option>
                                                                }
                                                            }

                                                        </InputSelect>
                                                    </div>
                                                    <div class="mapping-arrow">→</div>
                                                    <div class="mapping-col">
                                                        <label>Payload path</label>
                                                        <InputText @bind-Value="outputMapping.To" type="text"
                                                                   class="form-control form-control-sm"
                                                                   placeholder="e.g. name"
                                                                   aria-label="Target payload path for output mapping"
                                                                   required
                                                                   data-role="target-payload-path" />
                                                    </div>
                                                    <button onclick="@(() => RemoveMethodOutputToNodeOutputMap(outputMapping))"
                                                            type="button"
                                                            class="btn btn-icon btn-xs"
                                                            aria-label="Remove output mapping"
                                                            title="Remove this output mapping"
                                                            data-role="remove-mapping">
                                                        <span aria-hidden="true">✕</span>
                                                    </button>
                                                </div>
                                            }
                                        }
                                    </div>
                                </div>
                            }
                            else
                            {
                                <!-- Port-driven nodes don't use output mappings -->
                                <div class="panel-section" data-role="port-driven-info">
                                    <div class="alert alert-info" style="margin: 0;">
                                        <strong>Port-Driven Node</strong>
                                        <p style="margin: 0.5rem 0 0 0; font-size: 0.875rem;">
                                            This node uses port-driven execution with outputs: <strong>@string.Join(", ", BackingNode.DeclaredOutputPorts)</strong>
                                        </p>
                                        <p style="margin: 0.5rem 0 0 0; font-size: 0.875rem; color: #666;">
                                            Data provided by this node varies by port. Output mappings are not used—downstream nodes receive data automatically based on which port they're connected to.
                                        </p>
                                    </div>
                                </div>
                            }
                        </div>
                    </section>

                    <!-- OUTPUT PANEL -->
                    <section class="node-editor-panel node-editor-panel-output">
                        <header class="panel-header">
                            <span class="pill pill-output">Output</span>
                            <h6>Resulting payload</h6>
                            <p class="panel-caption">See what leaves this node after mappings.</p>
                        </header>
                        <div class="panel-body">
                            <div class="payload-preview payload-preview--output"
                                 data-role="output-preview">
                                @{
                                    var outputString = JsonSerializer.Serialize(OutputPayloadJson, new JsonSerializerOptions() { Encoder = System.Text.Encodings.Web.JavaScriptEncoder.UnsafeRelaxedJsonEscaping, WriteIndented = true });
                                    if (outputString == "null")
                                    {
                                        outputString = "...";
                                    }
                                }
                                @(outputString)
                            </div>

                            <hr class="panel-divider mt-3" />

                            <!-- Output Mapping Preview Section -->
                            <div class="panel-section">
                                <div class="panel-section-header">
                                    <span>Output Mapping Preview</span>
                                </div>
                                <div class="scriban-preview-list">
                                    @if (ViewModel.MethodOutputToNodeOutputMap.Any())
                                    {
                                        @foreach (var mapping in ViewModel.MethodOutputToNodeOutputMap.Where(m => !string.IsNullOrWhiteSpace(m.From) && !string.IsNullOrWhiteSpace(m.To)))
                                        {
                                            var outputValue = GetOutputPreviewValue(mapping.From);
                                            <div class="scriban-preview-item">
                                                <div class="scriban-preview-label">output.@mapping.To</div>
                                                <div class="scriban-preview-value">@outputValue</div>
                                            </div>
                                        }
                                    }
                                    else
                                    {
                                        <p class="text-muted small">No output mappings configured</p>
                                    }
                                </div>
                            </div>

                            <hr class="panel-divider mt-3" />

                            <div class="panel-section">
                                <div class="panel-section-header">
                                    <span>Flags</span>
                                </div>

                                <div class="form-check form-switch">
                                    <input @bind="BackingNode.MergeOutputWithInput" class="form-check-input"
                                           type="checkbox"
                                           id="replacePayload"
                                           data-role="replace-payload" />
                                    <label class="form-check-label" for="replacePayload">
                                        Merge Input into Output
                                    </label>
                                </div>

                                <div class="form-check form-switch mt-2">
                                    <input class="form-check-input"
                                           type="checkbox"
                                           id="debugNode"
                                           data-role="debug-node" />
                                    <label class="form-check-label" for="debugNode">
                                        Capture debug snapshot
                                    </label>
                                </div>
                            </div>
                        </div>
                    </section>
                </div>
            </div>

            <div class="modal-footer node-editor-footer">
                <button onclick="@HandleClose"
                        type="button"
                        class="btn btn-outline-secondary"
                        disabled="@isSaving"
                        aria-label="Cancel and close modal">
                    Cancel
                </button>
                <button onclick="@SaveMappings"
                        type="button"
                        class="btn btn-primary @(saveSuccess ? "save-success" : "")"
                        disabled="@isSaving"
                        aria-label="Save node mappings"
                        data-role="save-node">
                    @if (isSaving)
                    {
                        <span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>
                    }
                    @(isSaving ? "Saving..." : "Save mappings")
                </button>
            </div>
        </div>
    </div>
</div>

@code {
    [Parameter]
    public EventCallback CloseRequested { get; set; }

    [Parameter]
    public EventCallback SaveRequested { get; set; }

    [Parameter]
    public EventCallback ExecuteInputRequested { get; set; }

    [Parameter]
    public required Node BackingNode { get; set; } = new() { BackingMethod = null };

    [Parameter]
    public JsonNode? IncomingPayloadJson { get; set; }

    [Parameter]
    public JsonNode? OutputPayloadJson { get; set; }

    public NodeEditorModalViewModel ViewModel { get; set; } = new();
    private bool isSaving = false;
    private bool saveSuccess = false;
    private bool isExecuting = false;
    private string? _draggedFieldPath = null;

    protected override void OnParametersSet()
    {
        base.OnParametersSet();

        // Create a fresh ViewModel each time to avoid stale data
        ViewModel = new NodeEditorModalViewModel();

        // Initialize with existing mappings or populate with smart defaults
        if (BackingNode.NodeInputToMethodInputMap.Count == 0)
        {
            // Auto-populate input mappings with sensible defaults
            var defaultMappings = GenerateDefaultInputMappings();
            ViewModel.NodeInputToMethodInputMap = defaultMappings.Count > 0 ? defaultMappings : new List<PathMapEntry>();
        }
        else
        {
            // Filter out any blank/invalid entries when loading existing mappings
            // Keep entries only if BOTH From and To have values
            var validMappings = BackingNode.NodeInputToMethodInputMap
                .Where(m => !string.IsNullOrWhiteSpace(m.From) && !string.IsNullOrWhiteSpace(m.To))
                .ToList();
            ViewModel.NodeInputToMethodInputMap = validMappings.Count > 0 ? validMappings : GenerateDefaultInputMappings();
        }

        if (BackingNode.MethodOutputToNodeOutputMap.Count == 0)
        {
            // Auto-populate output mappings with property names or "result"
            var defaultMappings = GenerateDefaultOutputMappings();
            ViewModel.MethodOutputToNodeOutputMap = defaultMappings.Count > 0 ? defaultMappings : new List<PathMapEntry>();
        }
        else
        {
            // Filter out any blank/invalid entries when loading existing mappings
            // Keep entries only if BOTH From and To have values
            var validMappings = BackingNode.MethodOutputToNodeOutputMap
                .Where(m => !string.IsNullOrWhiteSpace(m.From) && !string.IsNullOrWhiteSpace(m.To))
                .ToList();
            ViewModel.MethodOutputToNodeOutputMap = validMappings.Count > 0 ? validMappings : GenerateDefaultOutputMappings();
        }

        OutputPayloadJson = BackingNode?.Result;
        IncomingPayloadJson = BackingNode?.Input;
    }

    private List<PathMapEntry> GenerateDefaultInputMappings()
    {
        var mappings = new List<PathMapEntry>();
        var parameters = BackingNode.BackingMethod?.GetParameters() ?? Array.Empty<ParameterInfo>();

        foreach (var param in parameters)
        {
            // Skip NodeContext and IServiceProvider parameters as they're handled automatically
            if (param.ParameterType == typeof(NodeContext) || param.ParameterType == typeof(IServiceProvider))
                continue;

            // Check if parameter has DrawflowInputField attribute (means it should be a literal)
            var hasInputFieldAttr = param.GetCustomAttribute<BlazorExecutionFlow.Flow.Attributes.BlazorFlowInputFieldAttribute>() != null;

            string defaultValue;
            if (hasInputFieldAttr)
            {
                // For input fields, provide a placeholder literal value
                defaultValue = GeneratePlaceholderLiteral(param.ParameterType, param.Name);
            }
            else
            {
                // For regular parameters, suggest mapping from input payload using template syntax
                defaultValue = $"{{{{input.{param.Name}}}}}";
            }

            mappings.Add(new PathMapEntry
            {
                From = defaultValue,
                To = param.Name ?? string.Empty
            });
        }

        return mappings;
    }

    private List<PathMapEntry> GenerateDefaultOutputMappings()
    {
        var mappings = new List<PathMapEntry>();
        var returnProps = GetReturnProperties();

        if (returnProps != null)
        {
            foreach (var prop in returnProps)
            {
                if (prop.Name != null)
                {
                    mappings.Add(new PathMapEntry
                    {
                        From = prop.Name,
                        To = prop.Name  // Map to same name by default
                    });
                }
            }
        }

        return mappings;
    }

    private string GeneratePlaceholderLiteral(Type paramType, string? paramName)
    {
        // Generate helpful placeholder values based on type
        if (paramType == typeof(string))
            return $"\"\"";  // Empty string placeholder
        if (paramType == typeof(int))
            return "0";
        if (paramType == typeof(double) || paramType == typeof(float))
            return "0.0";
        if (paramType == typeof(bool))
            return "false";
        if (paramType == typeof(DateTime))
            return $"\"{DateTime.Now:yyyy-MM-dd}\"";

        // For other types, try to provide a sensible default
        return "\"\"";
    }

    public List<(string? Type, string? Name)>? GetReturnProperties()
    {
        return TypeHelpers.GetReturnProperties(BackingNode.BackingMethod);
    }

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Escape" && !isSaving)
        {
            await HandleClose();
        }
    }

    private async Task HandleClose()
    {
        if (isSaving) return;
        await CloseRequested.InvokeAsync();
    }

    private async Task HandleBackdropClick()
    {
        await HandleClose();
    }

    private async Task ExecuteInput()
    {
        if (isExecuting) return;

        isExecuting = true;
        StateHasChanged();

        try
        {
            await ExecuteInputRequested.InvokeAsync();

            // Refresh the payload data after execution
            IncomingPayloadJson = BackingNode?.Input;
            OutputPayloadJson = BackingNode?.Result;

            StateHasChanged();

            await Task.Delay(1000);
        }
        catch (Exception ex)
        {
        }
        finally
        {
            isExecuting = false;
            StateHasChanged();
        }
    }

    private async Task SaveMappings()
    {
        if (isSaving) return;

        isSaving = true;
        StateHasChanged();

        try
        {
            // Filter out any blank entries before saving (keep only if BOTH From and To have values)
            BackingNode.MethodOutputToNodeOutputMap = ViewModel.MethodOutputToNodeOutputMap
                .Where(m => !string.IsNullOrWhiteSpace(m.From) && !string.IsNullOrWhiteSpace(m.To))
                .ToList();
            BackingNode.NodeInputToMethodInputMap = ViewModel.NodeInputToMethodInputMap
                .Where(m => !string.IsNullOrWhiteSpace(m.From) && !string.IsNullOrWhiteSpace(m.To))
                .ToList();
            await SaveRequested.InvokeAsync();

            saveSuccess = true;
            StateHasChanged();

            // Reset success animation after a delay
            await Task.Delay(300);
            saveSuccess = false;
        }
        catch (Exception ex)
        {
        }
        finally
        {
            isSaving = false;
            StateHasChanged();
        }
    }

    private void RemoveMethodOutputToNodeOutputMap(PathMapEntry viewModel)
    {
        ViewModel.MethodOutputToNodeOutputMap.Remove(viewModel);
        StateHasChanged();
    }

    private void RemoveNodeInputToMethodInputMap(PathMapEntry viewModel)
    {
        ViewModel.NodeInputToMethodInputMap.Remove(viewModel);
        StateHasChanged();
    }

    private void AddInputMapping()
    {
        var parameters = BackingNode?.BackingMethod?.GetParameters() ?? Array.Empty<ParameterInfo>();
        var mappedParams = new HashSet<string>(ViewModel.NodeInputToMethodInputMap.Select(m => m.To));

        // Find the first unmapped parameter
        var unmappedParam = parameters.FirstOrDefault(p =>
            p.ParameterType != typeof(NodeContext) &&
            p.ParameterType != typeof(IServiceProvider) &&
            !mappedParams.Contains(p.Name ?? string.Empty));

        if (unmappedParam != null)
        {
            // Add mapping with smart default
            var hasInputFieldAttr = unmappedParam.GetCustomAttribute<BlazorExecutionFlow.Flow.Attributes.BlazorFlowInputFieldAttribute>() != null;
            var defaultValue = hasInputFieldAttr
                ? GeneratePlaceholderLiteral(unmappedParam.ParameterType, unmappedParam.Name)
                : $"{{{{input.{unmappedParam.Name}}}}}";

            ViewModel.NodeInputToMethodInputMap.Add(new PathMapEntry
            {
                From = defaultValue,
                To = unmappedParam.Name ?? string.Empty
            });
            StateHasChanged();
        }
        // Don't add empty mapping if all parameters are already mapped
    }

    private void AddOutputMapping()
    {
        var returnProps = GetReturnProperties();
        if (returnProps != null && returnProps.Any())
        {
            var mappedProps = new HashSet<string>(ViewModel.MethodOutputToNodeOutputMap.Select(m => m.From));

            // Find the first unmapped property
            var unmappedProp = returnProps.FirstOrDefault(p =>
                p.Name != null &&
                !mappedProps.Contains(p.Name));

            if (unmappedProp.Name != null)
            {
                // Add mapping with property name as both source and target
                ViewModel.MethodOutputToNodeOutputMap.Add(new PathMapEntry
                {
                    From = unmappedProp.Name,
                    To = unmappedProp.Name
                });
                StateHasChanged();
            }
            // Don't add empty mapping if all properties are already mapped
        }
        else
        {
            // For non-object return types (e.g., int, string), check if "result" is already mapped
            var mappedProps = new HashSet<string>(ViewModel.MethodOutputToNodeOutputMap.Select(m => m.From));
            if (!mappedProps.Contains("result"))
            {
                ViewModel.MethodOutputToNodeOutputMap.Add(new PathMapEntry
                {
                    From = "result",
                    To = "result"
                });
                StateHasChanged();
            }
            // Don't add empty mapping if "result" is already mapped
        }
    }

    private bool CanAddInputMapping()
    {
        var parameters = BackingNode?.BackingMethod?.GetParameters() ?? Array.Empty<ParameterInfo>();
        var availableParams = parameters.Where(p =>
            p.ParameterType != typeof(NodeContext) &&
            p.ParameterType != typeof(IServiceProvider)).ToList();
        var mappedParams = new HashSet<string>(ViewModel.NodeInputToMethodInputMap.Select(m => m.To).Where(t => !string.IsNullOrEmpty(t)));

        // Can add if there are unmapped parameters
        return availableParams.Any(p => !mappedParams.Contains(p.Name ?? string.Empty));
    }

    private IEnumerable<ParameterInfo> GetAvailableInputParameters(PathMapEntry currentMapping)
    {
        var parameters = BackingNode?.BackingMethod?.GetParameters() ?? Array.Empty<ParameterInfo>();
        var availableParams = parameters.Where(p =>
            p.ParameterType != typeof(NodeContext) &&
            p.ParameterType != typeof(IServiceProvider)).ToList();

        // Get all mapped parameter names except the current one
        var mappedParams = new HashSet<string>(
            ViewModel.NodeInputToMethodInputMap
                .Where(m => m != currentMapping && !string.IsNullOrEmpty(m.To))
                .Select(m => m.To)
        );

        // Return parameters that are either not mapped or are the current mapping's target
        return availableParams.Where(p =>
            !mappedParams.Contains(p.Name ?? string.Empty) ||
            p.Name == currentMapping.To
        );
    }

    private bool CanAddOutputMapping()
    {
        var returnProps = GetReturnProperties();

        if (returnProps != null && returnProps.Any())
        {
            var mappedProps = new HashSet<string>(ViewModel.MethodOutputToNodeOutputMap.Select(m => m.From).Where(f => !string.IsNullOrEmpty(f)));
            // Can add if there are unmapped properties
            return returnProps.Any(p => p.Name != null && !mappedProps.Contains(p.Name));
        }
        else
        {
            // For non-object return types, can add if "result" is not mapped
            var mappedProps = new HashSet<string>(ViewModel.MethodOutputToNodeOutputMap.Select(m => m.From).Where(f => !string.IsNullOrEmpty(f)));
            return !mappedProps.Contains("result");
        }
    }

    private IEnumerable<(string? Type, string? Name)> GetAvailableOutputProperties(PathMapEntry currentMapping, List<(string? Type, string? Name)> allProps)
    {
        // Get all mapped property names except the current one
        var mappedProps = new HashSet<string>(
            ViewModel.MethodOutputToNodeOutputMap
                .Where(m => m != currentMapping && !string.IsNullOrEmpty(m.From))
                .Select(m => m.From)
        );

        // Return properties that are either not mapped or are the current mapping's source
        return allProps.Where(p =>
            p.Name != null && (
                !mappedProps.Contains(p.Name) ||
                p.Name == currentMapping.From
            )
        );
    }

    private bool IsOutputValueAvailable(PathMapEntry currentMapping, string value)
    {
        // Get all mapped values except the current one
        var mappedValues = new HashSet<string>(
            ViewModel.MethodOutputToNodeOutputMap
                .Where(m => m != currentMapping && !string.IsNullOrEmpty(m.From))
                .Select(m => m.From)
        );

        // Value is available if not mapped or is the current mapping's source
        return !mappedValues.Contains(value) || value == currentMapping.From;
    }

    public class NodeEditorModalViewModel
    {
        public List<PathMapEntry> NodeInputToMethodInputMap { get; set; } = new();
        public List<PathMapEntry> MethodOutputToNodeOutputMap { get; set; } = new();
    }

    private string GetScribanPreviewValue(string templateString)
    {
        if (string.IsNullOrWhiteSpace(templateString) || IncomingPayloadJson == null)
            return "N/A";

        try
        {
            // Check if value is a simple path reference (no Scriban template expressions)
            if (!templateString.Contains("{{") && !templateString.Contains("}}"))
            {
                var jsonValue = IncomingPayloadJson.GetByPath(templateString);
                if (jsonValue != null)
                {
                    return JsonSerializer.Serialize(jsonValue, new JsonSerializerOptions { WriteIndented = false });
                }
                // If it's not a path, treat it as a literal value
                return templateString;
            }

            // Fall back to template rendering for complex expressions
            var modelDict = IncomingPayloadJson.ToPlainObject()!;

            var scriptObject = new ScriptObject();
            scriptObject.Import(modelDict);

            var context = new TemplateContext();
            context.PushGlobal(scriptObject);

            var template = Template.Parse(templateString);
            var result = template.Render(context);

            return string.IsNullOrEmpty(result) ? "(empty)" : result;
        }
        catch (Exception ex)
        {
            return $"Error: {ex.Message}";
        }
    }

    private string GetOutputPreviewValue(string propertyPath)
    {
        if (string.IsNullOrWhiteSpace(propertyPath) || OutputPayloadJson == null)
            return "N/A";

        try
        {
            // For output, we're showing what value exists at the "From" property
            // This would come from the Result object after execution
            var outputSection = OutputPayloadJson["output"];
            if (outputSection == null)
                return "N/A";

            // Try to get the value at the property path
            var value = outputSection.AsObject()?.GetByPath(propertyPath);
            if (value != null)
            {
                return JsonSerializer.Serialize(value, new JsonSerializerOptions { WriteIndented = false });
            }

            return "N/A";
        }
        catch (Exception ex)
        {
            return $"Error: {ex.Message}";
        }
    }

    // Drag and Drop handlers
    private void HandleDragStart(DragEventArgs e, string fieldPath)
    {
        _draggedFieldPath = fieldPath;
    }

    private void HandleDragOver(DragEventArgs e)
    {
        // Allow drop by preventing default
    }

    private void HandleDrop(DragEventArgs e, PathMapEntry mapping)
    {
        if (!string.IsNullOrEmpty(_draggedFieldPath))
        {
            // Replace the content with Scriban template syntax
            mapping.From = $"{{{{{_draggedFieldPath}}}}}";
            _draggedFieldPath = null;
            StateHasChanged();
        }
    }
}